
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>cctbx.miller package &#8212; CCTBX Developer documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="cctbx.miller.display module" href="cctbx.miller.display.html" />
    <link rel="prev" title="cctbx.merging.brehm_diederichs module" href="cctbx.merging.brehm_diederichs.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cctbx.miller.display.html" title="cctbx.miller.display module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cctbx.merging.brehm_diederichs.html" title="cctbx.merging.brehm_diederichs module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CCTBX Developer documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="cctbx.html" accesskey="U">cctbx - core crystallographic objects and functions</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-cctbx.miller"></span><div class="section" id="cctbx-miller-package">
<h1>cctbx.miller package<a class="headerlink" href="#cctbx-miller-package" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="#module-cctbx.miller" title="cctbx.miller"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cctbx.miller</span></code></a> is one of the most important modules in CCTBX; it
encompasses nearly every operation performed directly on experimental data.
The core classes in cctbx.miller are the <span class="xref std std-ref">set</span> and the
<span class="xref std std-ref">array</span>.  The set (not to be confused with the built-in
Python type) contains the crystal symmetry, an array (type
<code class="xref py py-class docutils literal notranslate"><span class="pre">cctbx.array_family.flex.miller_index</span></code>) of Miller indices (h,k,l),
and a boolean flag indicating anomalous pairs.  It does not contain actual
data, although many of its methods will return an array.  The array subclasses
the Miller set and adds a flex array containing data (and, optionally, a
flex array of experimental sigmas) and many extensions for supporting a variety
of data types.  The underlying “data” is often X-ray amplitudes or intensities,
but many other array types are also supported.</p>
<p>One important distinction needs to be made for developers used to working with
specific file formats or more archaic programming languages: <strong>the Miller
arrays that you will work with do not necessarily correspond to a single
column of data in a reflection file</strong>.  There are several major differences:</p>
<ul class="simple">
<li><strong>Friedel mates</strong> will be stored separate if present.  This means that a
pair of columns <code class="docutils literal notranslate"><span class="pre">F(+)</span></code> and <code class="docutils literal notranslate"><span class="pre">F(-)</span></code> from an MTZ file will become a single
array with both <code class="docutils literal notranslate"><span class="pre">(h,k,l)</span></code> and <code class="docutils literal notranslate"><span class="pre">(-h,-k,-l)</span></code> present as distinct items.
The same also applies to any other data type.  (Note that one consequence
of this behavior is that the number of reflections will appear to
double-count acentric reflections for which both Friedel mates are present.)</li>
<li>For <strong>experimental data</strong> (amplitudes or intensities), the array will also
store the corresponding experimental sigmas; <code class="docutils literal notranslate"><span class="pre">array.data()</span></code> returns the
experimental data, while <code class="docutils literal notranslate"><span class="pre">array.sigmas()</span></code> returns sigmas.  In combination
with the treatment of anomalous data, this means that a single Miller array
can represent the combination of columns <code class="docutils literal notranslate"><span class="pre">I(+),SIGI(+),I(-),SIGI(-)</span></code> from
a file.</li>
<li><strong>Weighted map coefficients</strong> such as <code class="docutils literal notranslate"><span class="pre">FWT,DELFWT</span></code> or <code class="docutils literal notranslate"><span class="pre">2FOFCWT,PH2FOFCWT</span></code>
will be treated as a single array with data type
<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.complex_double" title="scitbx.array_family.flex.complex_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">scitbx.array_family.flex.complex_double</span></code></a>.</li>
<li><strong>Hendrickson-Lattman</strong> phase probability coefficients are also grouped
together, and have their own data type
<code class="xref py py-class docutils literal notranslate"><span class="pre">cctbx.array_family.flex.hendrickson_lattman</span></code>.</li>
</ul>
<p>These conventions greatly simplify keeping track of and manipulating related
data items.
Output to various file formats will still follow the appropriate conventions.</p>
<div class="section" id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>Miller sets (and arrays) can be created in three ways: programatically, by
reading from a file, or from a <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">cctbx.xray.structure</span></code></a> object.  (In
practice, the latter two options almost always return an array object rather
than a set.)  Programmatic creation can be done directly, or through the
convenience method <a class="reference internal" href="#cctbx.miller.build_set" title="cctbx.miller.build_set"><code class="xref py py-func docutils literal notranslate"><span class="pre">cctbx.miller.build_set()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">miller</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">crystal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">build_set</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">crystal_symmetry</span><span class="o">=</span><span class="n">crystal</span><span class="o">.</span><span class="n">symmetry</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">space_group_symbol</span><span class="o">=</span><span class="s2">&quot;P212121&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">unit_cell</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="n">anomalous_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">d_min</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">ms</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 2), (0, 1, 1), (0, 2, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (2, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">ms</span><span class="o">.</span><span class="n">d_max_min</span><span class="p">()</span>
<span class="go">(4.242640687119285, 3.0)</span>
</pre></div>
</div>
<p>The same set, instantiated directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">miller</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">crystal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx.array_family</span> <span class="kn">import</span> <span class="n">flex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">crystal_symmetry</span><span class="o">=</span><span class="n">crystal</span><span class="o">.</span><span class="n">symmetry</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">space_group_symbol</span><span class="o">=</span><span class="s2">&quot;P212121&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">unit_cell</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="n">anomalous_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">indices</span><span class="o">=</span><span class="n">flex</span><span class="o">.</span><span class="n">miller_index</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]))</span>
</pre></div>
</div>
<p>From here we can retrieve a variety of information, even before we have
experimental data.  For instance, exploring systematic absences (starting
from the above example):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">sgtbx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point_group</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">space_group</span><span class="p">()</span><span class="o">.</span><span class="n">build_derived_point_group</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms_base</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span><span class="n">space_group</span><span class="o">=</span><span class="n">point_group</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms_all</span> <span class="o">=</span> <span class="n">ms_base</span><span class="o">.</span><span class="n">complete_set</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">lone_set</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">ms_base</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">sys_abs</span><span class="p">)</span>
<span class="go">&lt;class &#39;cctbx.miller.set&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 1), (0, 1, 0), (1, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms_all_p212121</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">space_group_info</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">space_group_info</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs_flags</span> <span class="o">=</span> <span class="n">ms_all_p212121</span><span class="o">.</span><span class="n">sys_absent_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="p">)</span>
<span class="go">&lt;class &#39;cctbx.miller.array&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 1), (0, 0, 2), (0, 1, 0), (0, 1, 1), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (2, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="go">[True, False, True, False, False, True, False, False, False, False]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all_p212121</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 1), (0, 1, 0), (1, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_sys_abs</span> <span class="o">=</span> <span class="n">ms_all_p212121</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">not_sys_abs</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 2), (0, 1, 1), (0, 2, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (2, 0, 0)]</span>
</pre></div>
</div>
<p>This block of code performed the following actions:</p>
<ul class="simple">
<li>change the symmetry to the point group (<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></code>) corresponding to the
original space group (<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></code>)</li>
<li>generate the complete list of reflections for the new set in <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></code></li>
<li>obtain the “lone set” of reflections missing from the original set relative
to the new complete set; these correspond to reflections that are
systematically absent in <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></code> (but not <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></code>)</li>
<li>change the symmetry for the complete set in <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></code> back to the original
space group <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></code></li>
<li>call the method <code class="docutils literal notranslate"><span class="pre">sys_absent_flags()</span></code> to obtain a Miller array whose data
are a <code class="docutils literal notranslate"><span class="pre">flex.bool</span></code> array indicating those reflections that are
systematically absent</li>
<li>call the method <code class="docutils literal notranslate"><span class="pre">select()</span></code> using the resulting boolean array and its
inverse, first to extract the set of systematic absences for
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></code>, and then extract the non-absent set we started with</li>
</ul>
<p>There are two more important details that are not immediately obvious from
the code example:</p>
<p>1) <code class="docutils literal notranslate"><span class="pre">customized_copy()</span></code> will create a new <code class="docutils literal notranslate"><span class="pre">set</span></code> object, but it will not
copy any underlying <code class="docutils literal notranslate"><span class="pre">flex</span></code> arrays (the same applies to the <code class="docutils literal notranslate"><span class="pre">array</span></code>
class).  This means that modifications to these arrays via the new copy will
be propagated back to the original object.  If you want to avoid this
behavior, use the <code class="docutils literal notranslate"><span class="pre">deep_copy()</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ms_base</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span><span class="n">space_group</span><span class="o">=</span><span class="n">point_group</span><span class="p">)</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">()</span>
</pre></div>
</div>
<p>2) The comparison of sets in <code class="docutils literal notranslate"><span class="pre">lone_set()</span></code>, and in general most other methods
that involve an <code class="docutils literal notranslate"><span class="pre">other</span></code> argument, will fail if the crystal symmetry is
not identical.  For instance, in the above example, if we instead tried to
call <code class="docutils literal notranslate"><span class="pre">lone_set()</span></code> using the original <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></code> set as <code class="docutils literal notranslate"><span class="pre">other</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">lone_set</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">ms</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1047</span>, in <span class="n">lone_set</span>
    <span class="n">assert_is_similar_symmetry</span><span class="o">=</span><span class="n">assert_is_similar_symmetry</span><span class="p">)</span><span class="o">.</span><span class="n">singles</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  File <span class="nb">&quot;/Users/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1007</span>, in <span class="n">match_indices</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_similar_symmetry</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gr">AssertionError</span>
</pre></div>
</div>
<p>We can prevent this if we want:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">lone_set</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">ms</span><span class="p">,</span> <span class="n">assert_is_similar_symmetry</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>However, you should use caution when disabling the symmetry check, as this
will also mean that comparisons between radically different crystal symmetries
(e.g. <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">63</span> <span class="pre">2</span> <span class="pre">2</span></code> versus <code class="docutils literal notranslate"><span class="pre">I</span> <span class="pre">41</span></code>) will be performed silently.</p>
</div>
<div class="section" id="file-i-o">
<h2>File I/O<a class="headerlink" href="#file-i-o" title="Permalink to this headline">¶</a></h2>
<p>Of course, if you are interested in working with actual experimental data,
additional APIs are required.  Methods for reading input files are covered in
more detail in the documentation for <a class="reference internal" href="../iotbx/iotbx.reflection_file_reader.html#module-iotbx.reflection_file_reader" title="iotbx.reflection_file_reader"><code class="xref py py-mod docutils literal notranslate"><span class="pre">iotbx.reflection_file_reader</span></code></a>
and <a class="reference internal" href="../iotbx/iotbx.file_reader.html#module-iotbx.file_reader" title="iotbx.file_reader"><code class="xref py py-mod docutils literal notranslate"><span class="pre">iotbx.file_reader</span></code></a>, but in the simplest case we can obtain
experimental data in just a couple of lines of code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">iotbx.reflection_file_reader</span> <span class="kn">import</span> <span class="n">any_reflection_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hkl_in</span> <span class="o">=</span> <span class="n">any_reflection_file</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;data.sca&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">miller_arrays</span> <span class="o">=</span> <span class="n">hkl_in</span><span class="o">.</span><span class="n">as_miller_arrays</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span> <span class="o">=</span> <span class="n">miller_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>This of course assumes that the file format includes crystal symmetry, which
is not the case for some popular formats; in these cases you will need to
obtain the symmetry information separately and pass it to
<code class="docutils literal notranslate"><span class="pre">as_miller_arrays()</span></code>.</p>
<p>Some of the file metadata will be preserved in the embedded <code class="docutils literal notranslate"><span class="pre">array_info</span></code>
object; other attributes are properties of the array itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
<span class="go">data.sca:I(+),SIGI(+),I(-),SIGI(-)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">observation_type</span><span class="p">()</span>
<span class="go">xray.intensity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span><span class="o">.</span><span class="n">show_summary</span><span class="p">()</span>
<span class="go">Miller array info: data.sca:I(+),SIGI(+),I(-),SIGI(-)</span>
<span class="go">Observation type: xray.intensity</span>
<span class="go">Type of data: double, size=7</span>
<span class="go">Type of sigmas: double, size=7</span>
<span class="go">Number of Miller indices: 7</span>
<span class="go">Anomalous flag: False</span>
<span class="go">Unit cell: (6.000, 6.000, 6.000, 90, 90, 90)</span>
<span class="go">Space group: P 21 21 21 (No. 19)</span>
<span class="go">&lt;cctbx.miller.array object at 0x1071a6690&gt;</span>
</pre></div>
</div>
<p>(The final line is simply printing the Python representation of the array
itself - this is because the <code class="docutils literal notranslate"><span class="pre">show_summary()</span></code> method returns a reference to
<code class="docutils literal notranslate"><span class="pre">self</span></code>, which allows <strong>chaining</strong> of successive methods.)  Note that the
<code class="docutils literal notranslate"><span class="pre">array_info</span></code> object returned by <code class="docutils literal notranslate"><span class="pre">array.info()</span></code> contains the file name
and original column labels; elsewhere, these attributes are used to select
specific arrays from multi-purpose formats such as MTZ.</p>
<p>From here we can quickly convert to amplitudes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span> <span class="o">=</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">f_sq_as_f</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">observation_type</span><span class="p">()</span>
<span class="go">xray.amplitude</span>
</pre></div>
</div>
<p>(Note that for macromolecular data, the more sophisticated French-Wilson
treatment is recommended for dealing sensibly with weak or negative
intensities; this can be performed by calling <code class="docutils literal notranslate"><span class="pre">array.french_wilson()</span></code>.  For
many purposes, however, the simpler and faster <code class="docutils literal notranslate"><span class="pre">f_sq_as_f()</span></code> will be
sufficient.)</p>
<p>The Miller array can also be easily output to CIF, MTZ, Scalepack (unmerged
format only), SHELX, or CNS formats, although some restrictions apply.  Some
of these methods (where the format is limited to certain data types) can
directly write to a file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span><span class="o">.</span><span class="n">export_as_scalepack_unmerged</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;data2.sca&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;data.hkl&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span><span class="o">.</span><span class="n">export_as_shelx_hklf</span><span class="p">(</span><span class="n">file_object</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Others require multiple steps, but this has the advantage of allowing multiple
arrays to be combined (provided that they have identical crystal symmetry):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span> <span class="o">=</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">as_mtz_dataset</span><span class="p">(</span><span class="n">column_root_label</span><span class="o">=</span><span class="s2">&quot;I&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span><span class="o">.</span><span class="n">add_miller_array</span><span class="p">(</span><span class="n">f_obs</span><span class="p">,</span> <span class="n">column_root_label</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span><span class="o">.</span><span class="n">add_miller_array</span><span class="p">(</span><span class="n">r_free_flags</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">column_root_label</span><span class="o">=</span><span class="s2">&quot;FreeR_flag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span><span class="o">.</span><span class="n">mtz_object</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;data.mtz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to conventional formats, since all of the internal types can be
serialized as Python pickles, the same applies to set and array objects.</p>
<div class="section" id="processing-input-data-practical-aspects">
<h3>Processing input data - practical aspects<a class="headerlink" href="#processing-input-data-practical-aspects" title="Permalink to this headline">¶</a></h3>
<p>In practice, preparing input arrays for the various other algorithms in CCTBX
is often significantly more complicated than implied in the previous section.
Suppose for example we have an MTZ
file with these columns (output excerpted from <code class="docutils literal notranslate"><span class="pre">phenix.mtz.dump</span> <span class="pre">data.mtz</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">label</span>      <span class="c1">#valid  %valid    min     max type</span>
<span class="n">H</span>           <span class="mi">75612</span> <span class="mf">100.00</span><span class="o">%</span> <span class="o">-</span><span class="mf">40.00</span>   <span class="mf">38.00</span> <span class="n">H</span><span class="p">:</span> <span class="n">index</span> <span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span>
<span class="n">K</span>           <span class="mi">75612</span> <span class="mf">100.00</span><span class="o">%</span>   <span class="mf">0.00</span>   <span class="mf">25.00</span> <span class="n">H</span><span class="p">:</span> <span class="n">index</span> <span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span>
<span class="n">L</span>           <span class="mi">75612</span> <span class="mf">100.00</span><span class="o">%</span>   <span class="mf">0.00</span>   <span class="mf">70.00</span> <span class="n">H</span><span class="p">:</span> <span class="n">index</span> <span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span>
<span class="n">I</span><span class="p">(</span><span class="o">+</span><span class="p">)</span>        <span class="mi">74981</span>  <span class="mf">99.17</span><span class="o">%</span> <span class="o">-</span><span class="mf">11.10</span> <span class="mf">2777.70</span> <span class="n">K</span><span class="p">:</span> <span class="n">I</span><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">or</span> <span class="n">I</span><span class="p">(</span><span class="o">-</span><span class="p">)</span>
<span class="n">SIGI</span><span class="p">(</span><span class="o">+</span><span class="p">)</span>     <span class="mi">74981</span>  <span class="mf">99.17</span><span class="o">%</span>   <span class="mf">0.10</span>   <span class="mf">89.50</span> <span class="n">M</span><span class="p">:</span> <span class="n">standard</span> <span class="n">deviation</span>
<span class="n">I</span><span class="p">(</span><span class="o">-</span><span class="p">)</span>        <span class="mi">69529</span>  <span class="mf">91.95</span><span class="o">%</span> <span class="o">-</span><span class="mf">14.00</span> <span class="mf">2808.50</span> <span class="n">K</span><span class="p">:</span> <span class="n">I</span><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">or</span> <span class="n">I</span><span class="p">(</span><span class="o">-</span><span class="p">)</span>
<span class="n">SIGI</span><span class="p">(</span><span class="o">-</span><span class="p">)</span>     <span class="mi">69529</span>  <span class="mf">91.95</span><span class="o">%</span>   <span class="mf">0.10</span>   <span class="mf">64.90</span> <span class="n">M</span><span class="p">:</span> <span class="n">standard</span> <span class="n">deviation</span>
<span class="n">FreeR_flag</span>  <span class="mi">75773</span> <span class="mf">100.00</span><span class="o">%</span>   <span class="mf">0.00</span>    <span class="mf">1.00</span> <span class="n">I</span><span class="p">:</span> <span class="n">integer</span>
</pre></div>
</div>
<p>We would eventually like to be able to use these data for calculation of
R-factors (versus some hypothetical set of structure factors derived from a
model or map).  This requires several steps to ensure that any subsequent
actions will behave sensibly: we must make sure that the input data are of
the correct type, symmetry-unique, using conventional indices, and consistent
with the R-free flags; we also want to use the R-free flags to separate out
“working” and “test” arrays.  To begin with, we read in the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">iotbx.reflection_file_reader</span> <span class="kn">import</span> <span class="n">any_reflection_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hkl_in</span> <span class="o">=</span> <span class="n">any_reflection_file</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;data.mtz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">miller_arrays</span> <span class="o">=</span> <span class="n">hkl_in</span><span class="o">.</span><span class="n">as_miller_arrays</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span> <span class="o">=</span> <span class="n">miller_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags</span> <span class="o">=</span> <span class="n">miller_arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span> <span class="o">=</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">f_sq_as_f</span><span class="p">()</span><span class="o">.</span><span class="n">map_to_asu</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">map_to_asu</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">merge_equivalents</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">merge_equivalents</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags_plus_minus</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">generate_bijvoet_mates</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span><span class="p">,</span> <span class="n">flags_plus_minus</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">flags_plus_minus</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs_work</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="n">flags_plus_minus</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs_free</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flags_plus_minus</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
</pre></div>
</div>
<p>By the end of this block of code, we have ensured that the experimental
amplitudes and R-free flags have identically sized and ordered arrays, and
are suitable for comparison with any other (similarly prepared) set of data.
A number of consistency checks built in to the various set and array methods
may raise exceptions if these steps are skipped - for instance, the separate
storage of <code class="docutils literal notranslate"><span class="pre">(h,k,l)</span></code> and <code class="docutils literal notranslate"><span class="pre">(-h,-k,-l)</span></code> requires us to expand the R-free
flags to be “anomalous”, and if we skip that step:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1032</span>, in <span class="n">common_sets</span>
    <span class="n">assert_is_similar_symmetry</span><span class="o">=</span><span class="n">assert_is_similar_symmetry</span><span class="p">)</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1008</span>, in <span class="n">match_indices</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">anomalous_flag</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">anomalous_flag</span><span class="p">()</span>
<span class="gr">AssertionError</span>
</pre></div>
</div>
<p>Or if we omit the call to <code class="docutils literal notranslate"><span class="pre">common_sets()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs_work</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="n">flags_plus_minus</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">3232</span>, in <span class="n">select</span>
    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
<span class="gr">RuntimeError</span>: <span class="n">scitbx Internal Error: /home/nat/src/cctbx_project/scitbx/array_family/selections.h(44): SCITBX_ASSERT(flags.size() == self.size()) failure.</span>
</pre></div>
</div>
<p>(In practice, our use of <code class="docutils literal notranslate"><span class="pre">common_sets()</span></code> here is less than ideal; programs
in Phenix instead check that every reflection for which we have data also has
a corresponding R-free flag - after expansion to anomalous if necessary - and
exit with an error if this is not the case.)</p>
<p>Note that in the above example we are making many assumptions about the
contents and order of the input file, whereas in practice MTZ and CIF formats
may be arbitrarily complex and contain multiple arrays of each type.
(Additionally, the conventions for specifying R-free flags differ between
various software suites, and <code class="docutils literal notranslate"><span class="pre">1</span></code> will not necessarily be the appropriate
test flag value; fortunately, it is usually possible to guess the convention
being used.)   For
actual applications (as opposed to quick scripts and development code),
the utilities available in <code class="xref py py-mod docutils literal notranslate"><span class="pre">iotbx.reflection_file_utils</span></code> enable
standardized retrieval of different array types based on a combination of
automatic behavior and user input (i.e. label strings), and the general-purpose
input wrapper in <a class="reference internal" href="../mmtbx/mmtbx.command_line.html#module-mmtbx.command_line" title="mmtbx.command_line"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mmtbx.command_line</span></code></a> encapsulates nearly all of these
steps.</p>
</div>
</div>
<div class="section" id="comparing-arrays">
<h2>Comparing arrays<a class="headerlink" href="#comparing-arrays" title="Permalink to this headline">¶</a></h2>
<p>Here is a slightly more complex example of comparing data output by a
refinement program.  The input arrays are assumed to already be merged and
in the same ASU, but normally this would be taken care of by previous routines.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_r_factors</span> <span class="p">(</span><span class="n">fobs</span><span class="p">,</span> <span class="n">fmodel</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="p">:</span>
  <span class="n">fmodel</span><span class="p">,</span> <span class="n">fobs</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">fobs</span><span class="p">)</span>
  <span class="n">fmodel</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
  <span class="n">fc_work</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">()))</span>
  <span class="n">fo_work</span> <span class="o">=</span> <span class="n">fobs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">()))</span>
  <span class="n">fc_test</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
  <span class="n">fo_test</span> <span class="o">=</span> <span class="n">fobs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
  <span class="n">r_work</span> <span class="o">=</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">fc_work</span><span class="p">)</span>
  <span class="n">r_free</span> <span class="o">=</span> <span class="n">fo_test</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">fc_test</span><span class="p">)</span>
  <span class="nb">print</span> <span class="s2">&quot;r_work = </span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">r_work</span>
  <span class="nb">print</span> <span class="s2">&quot;r_free = </span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">r_free</span>
  <span class="nb">print</span> <span class="s2">&quot;&quot;</span>
  <span class="n">flags</span><span class="o">.</span><span class="n">setup_binner</span><span class="p">(</span><span class="n">n_bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
  <span class="n">fo_work</span><span class="o">.</span><span class="n">use_binning_of</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
  <span class="n">fc_work</span><span class="o">.</span><span class="n">use_binner_of</span><span class="p">(</span><span class="n">fo_work</span><span class="p">)</span>
  <span class="n">fo_test</span><span class="o">.</span><span class="n">use_binning_of</span><span class="p">(</span><span class="n">fo_work</span><span class="p">)</span>
  <span class="n">fc_test</span><span class="o">.</span><span class="n">use_binning_of</span><span class="p">(</span><span class="n">fo_work</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i_bin</span> <span class="ow">in</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">range_all</span><span class="p">()</span> <span class="p">:</span>
    <span class="n">sel_work</span> <span class="o">=</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">selection</span><span class="p">(</span><span class="n">i_bin</span><span class="p">)</span>
    <span class="n">sel_test</span> <span class="o">=</span> <span class="n">fo_test</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">selection</span><span class="p">(</span><span class="n">i_bin</span><span class="p">)</span>
    <span class="n">fo_work_bin</span> <span class="o">=</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_work</span><span class="p">)</span>
    <span class="n">fc_work_bin</span> <span class="o">=</span> <span class="n">fc_work</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_work</span><span class="p">)</span>
    <span class="n">fo_test_bin</span> <span class="o">=</span> <span class="n">fo_test</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_test</span><span class="p">)</span>
    <span class="n">fc_test_bin</span> <span class="o">=</span> <span class="n">fc_test</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_test</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fc_test_bin</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span> <span class="k">continue</span>
    <span class="n">r_work_bin</span> <span class="o">=</span> <span class="n">fo_work_bin</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">fc_work_bin</span><span class="p">,</span>
      <span class="n">assume_index_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">r_free_bin</span> <span class="o">=</span> <span class="n">fo_test_bin</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">fc_test_bin</span><span class="p">,</span>
      <span class="n">assume_index_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cc_work_bin</span> <span class="o">=</span> <span class="n">fo_work_bin</span><span class="o">.</span><span class="n">correlation</span><span class="p">(</span><span class="n">fc_work_bin</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient</span><span class="p">()</span>
    <span class="n">cc_free_bin</span> <span class="o">=</span> <span class="n">fo_test_bin</span><span class="o">.</span><span class="n">correlation</span><span class="p">(</span><span class="n">fc_test_bin</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient</span><span class="p">()</span>
    <span class="n">legend</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">bin_legend</span><span class="p">(</span><span class="n">i_bin</span><span class="p">,</span> <span class="n">show_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">  </span><span class="si">%8d</span><span class="s2"> </span><span class="si">%8d</span><span class="s2">  </span><span class="si">%.4f</span><span class="s2"> </span><span class="si">%.4f</span><span class="s2">  </span><span class="si">%.3f</span><span class="s2"> </span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="n">fo_work_bin</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span>
      <span class="n">fo_test_bin</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">r_work_bin</span><span class="p">,</span> <span class="n">r_free_bin</span><span class="p">,</span> <span class="n">cc_work_bin</span><span class="p">,</span> <span class="n">cc_free_bin</span><span class="p">)</span>
</pre></div>
</div>
<p>(The full source code is available in
<code class="docutils literal notranslate"><span class="pre">iotbx/examples/recalculate_phenix_refine_r_factors.py</span></code>.)</p>
</div>
<div class="section" id="working-with-experimental-data">
<h2>Working with experimental data<a class="headerlink" href="#working-with-experimental-data" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
<div class="section" id="from-arrays-to-maps">
<h2>From arrays to maps<a class="headerlink" href="#from-arrays-to-maps" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fft_map</span> <span class="o">=</span> <span class="n">map_coeffs</span><span class="o">.</span><span class="n">fft_map</span><span class="p">(</span><span class="n">resolution_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="n">fft_map</span><span class="o">.</span><span class="n">apply_sigma_scaling</span><span class="p">()</span>
<span class="n">real_map</span> <span class="o">=</span> <span class="n">fft_map</span><span class="o">.</span><span class="n">real_map_unpadded</span><span class="p">()</span>
<span class="n">site_map_values</span> <span class="o">=</span> <span class="n">flex</span><span class="o">.</span><span class="n">double</span><span class="p">()</span>
<span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">xray_structure</span><span class="o">.</span><span class="n">sites_frac</span><span class="p">()</span> <span class="p">:</span>
  <span class="n">rho</span> <span class="o">=</span> <span class="n">real_map</span><span class="o">.</span><span class="n">eight_point_interpolation</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
  <span class="n">site_map_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
</pre></div>
</div>
<p>As an extreme example of the ease of scripting repetitive actions using
<code class="docutils literal notranslate"><span class="pre">cctbx.miller</span></code>, here is a complete six-line script to convert all sets of map
coefficients in an MTZ file to sigma-scaled CCP4-format map files (covering the
unit cell):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">iotbx.reflection_file_reader</span> <span class="kn">import</span> <span class="n">any_reflection_file</span>
<span class="n">hkl_in</span> <span class="o">=</span> <span class="n">any_reflection_file</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;map_coeffs.mtz&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i_map</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hkl_in</span><span class="o">.</span><span class="n">as_miller_arrays</span><span class="p">())</span> <span class="p">:</span>
  <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">is_complex_array</span><span class="p">()</span> <span class="p">:</span>
    <span class="n">fft_map</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">fft_map</span><span class="p">(</span><span class="n">resolution_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span><span class="o">.</span><span class="n">apply_sigma_scaling</span><span class="p">()</span>
    <span class="n">fft_map</span><span class="o">.</span><span class="n">as_ccp4_map</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;map_</span><span class="si">%d</span><span class="s2">.ccp4&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i_map</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>See the documentation for <a class="reference internal" href="cctbx.maptbx.html#module-cctbx.maptbx" title="cctbx.maptbx"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cctbx.maptbx</span></code></a> for details of working with
map objects.</p>
</div>
<div class="section" id="the-miller-set">
<h2>The Miller set<a class="headerlink" href="#the-miller-set" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cctbx.miller.set">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">set</code><span class="sig-paren">(</span><em>crystal_symmetry</em>, <em>indices</em>, <em>anomalous_flag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="cctbx.crystal.html#cctbx.crystal.symmetry" title="cctbx.crystal.symmetry"><code class="xref py py-class docutils literal notranslate"><span class="pre">cctbx.crystal.symmetry</span></code></a></p>
<p>Basic class for handling sets of Miller indices (h,k,l), including sorting
and matching functions, symmetry handling, generation of R-free flags, and
extraction of associated statistics.  Does not actually contain data, but
this can be added using the array(…) method.</p>
<dl class="method">
<dt id="cctbx.miller.set.all_selection">
<code class="descname">all_selection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.all_selection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.amplitude_normalisations">
<code class="descname">amplitude_normalisations</code><span class="sig-paren">(</span><em>asu_contents</em>, <em>wilson_plot</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.amplitude_normalisations" title="Permalink to this definition">¶</a></dt>
<dd><p>A miller.array whose data N(h) are the normalisations to convert
between E’s and F’s:
E(h) = F(h) / N(h)
The argument wilson_plot shall feature attributes
- wilson_intensity_scale_factor
- wilson_b</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.anomalous_flag">
<code class="descname">anomalous_flag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.anomalous_flag" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate whether the set or array is anomalous or not.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.array">
<code class="descname">array</code><span class="sig-paren">(</span><em>data=None</em>, <em>sigmas=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array object, given data and/or sigma arrays of identical
dimensions to the indices array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> – a flex array (any format) or None</li>
<li><strong>sigmas</strong> – a flex array (any format, but almost always double) or None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.as_anomalous_set">
<code class="descname">as_anomalous_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.as_anomalous_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the set using the same indices but with the anomalous flag
set to true.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.as_non_anomalous_set">
<code class="descname">as_non_anomalous_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.as_non_anomalous_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the set using the same indices but with the anomalous flag
set to false.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.at_first_index">
<code class="descname">at_first_index</code><span class="sig-paren">(</span><em>ary</em>, <em>miller_index</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.at_first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element <cite>ary</cite> coresponding to the <cite>miller_index</cite> if
<a href="#id1"><span class="problematic" id="id2">`</span></a>miller_index exists, otherwise returns None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>miller_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a>) – Miller index as a 3-tuple</li>
<li><strong>ary</strong> (<em>sequence</em><em> (</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>, </em><a class="reference internal" href="#cctbx.miller.array" title="cctbx.miller.array"><em>array</em></a><em>, </em><em>etc</em><em>)</em>) – any array (e.g. self.data(), self.sigmas())</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">type of contents of <cite>ary</cite>, or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.auto_anomalous">
<code class="descname">auto_anomalous</code><span class="sig-paren">(</span><em>min_n_bijvoet_pairs=None</em>, <em>min_fraction_bijvoet_pairs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.auto_anomalous" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the anomalous flag automatically depending on whether the data
contain Bijvoet pairs (optionally given minimum cutoffs).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a copy of the set with (maybe) a new anomalous flag</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.binner">
<code class="descname">binner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.binner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the current resolution binner (or None if undefined).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.centric_flags">
<code class="descname">centric_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.centric_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a boolean Miller array flagging centric reflections.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.change_basis">
<code class="descname">change_basis</code><span class="sig-paren">(</span><em>cb_op</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.change_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transformation of the miller set with a new basis specified by cb_op</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cb_op</strong> (<em>string</em><em> or </em><em>sgtbx.change_of_basis_operator</em>) – object describing the desired transformation of the basis</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a new miller set with the new basis</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#cctbx.miller.set" title="cctbx.miller.set">cctbx.miller.set</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.clear_binner">
<code class="descname">clear_binner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.clear_binner" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.common_set">
<code class="descname">common_set</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.common_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the indices in the current set and another set, and return a set
(or array) containing only those reflections present in both.  Assumes that
both sets are already in the asymmetric unit (ASU).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.common_sets">
<code class="descname">common_sets</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em>, <em>assert_no_singles=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.common_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Like common_set(other), but returns a tuple containing matching copies of
both sets (or arrays).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.complete_set">
<code class="descname">complete_set</code><span class="sig-paren">(</span><em>d_min_tolerance=1e-06</em>, <em>d_min=None</em>, <em>d_max=None</em>, <em>max_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.complete_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the complete set of Miller indices expected for the current
symmetry, excepting systematic absences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d_min_tolerance</strong> – tolerance factor for d_min (avoid precision errors)</li>
<li><strong>d_min</strong> – High-resolution limit (default = d_min of current set)</li>
<li><strong>d_max</strong> – Low-resolution limit (default = d_max of current set)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.completeness">
<code class="descname">completeness</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>d_min_tolerance=1e-06</em>, <em>return_fail=None</em>, <em>d_max=None</em>, <em>multiplier=1</em>, <em>as_non_anomalous_array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the (fractional) completeness of the array relative to the
theoretical complete set, either overall or in resolution bins.  By default
the current low-resolution limit will be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d_min_tolerance</strong> – tolerance factor for d_min (avoid precision errors)</li>
<li><strong>d_max</strong> – Low-resolution limit (default = d_max of current set)</li>
<li><strong>multiplier</strong> – Factor to multiply the result by (usually 1 or 100)</li>
<li><strong>as_non_anomalous_array</strong> – Report values for non-anomalous array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.concatenate">
<code class="descname">concatenate</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two Miller sets.  Both must have the same anomalous flag, and
similar symmetry is also assumed.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the set, keeping references to the same crystal symmetry
and indices.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.crystal_gridding">
<code class="descname">crystal_gridding</code><span class="sig-paren">(</span><em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>grid_step=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.crystal_gridding" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate real-space grid for FFT given array crystal symmetry, d_min, and
desired resolution-dependent spacing.  The actual grid dimensions will be
adjusted to suit the needs of the FFT algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.crystal_symmetry">
<code class="descname">crystal_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.crystal_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get crystal symmetry of the miller set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new crystal.symmetry object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="cctbx.crystal.html#cctbx.crystal.symmetry" title="cctbx.crystal.symmetry">cctbx.crystal.symmetry</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.customized_copy">
<code class="descname">customized_copy</code><span class="sig-paren">(</span><em>crystal_symmetry=Keep</em>, <em>indices=Keep</em>, <em>anomalous_flag=Keep</em>, <em>unit_cell=Keep</em>, <em>space_group_info=Keep</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.customized_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the set, optionally changing the symmetry, indices,
and/or anomalous flag (default = keep all unmodified).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_max_min">
<code class="descname">d_max_min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.d_max_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Low- and high-resolution limits.
:returns: Python tuple of floats</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_min">
<code class="descname">d_min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.d_min" title="Permalink to this definition">¶</a></dt>
<dd><p>High-resolution limit.
:returns: Python float</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_min_along_a_b_c_star">
<code class="descname">d_min_along_a_b_c_star</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.d_min_along_a_b_c_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the effective resolution limits along the reciprocal space axes.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_spacings">
<code class="descname">d_spacings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.d_spacings" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a double Miller array containing the resolution d of each
index.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_star_cubed">
<code class="descname">d_star_cubed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.d_star_cubed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_star_sq">
<code class="descname">d_star_sq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.d_star_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.debye_waller_factors">
<code class="descname">debye_waller_factors</code><span class="sig-paren">(</span><em>u_iso=None</em>, <em>b_iso=None</em>, <em>u_cart=None</em>, <em>b_cart=None</em>, <em>u_cif=None</em>, <em>u_star=None</em>, <em>exp_arg_limit=50</em>, <em>truncate_exp_arg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.debye_waller_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an isotropic or anisotropic displacement or B-factor, alculate
resolution-dependent scale factors corresponding to the indices.
(Note that to simply apply one of the input parameters to an existing
Miller array, you can call array.apply_debye_waller_factors)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u_iso</strong> – Isotropic displacement (in Angstroms)</li>
<li><strong>b_iso</strong> – Isotropic B-factor (8*pi^2*u_iso^2)</li>
<li><strong>u_cart</strong> – Anisotropic displacement tensor</li>
<li><strong>b_cart</strong> – Anisotropic B-factor</li>
<li><strong>u_star</strong> – Anisotropic displacement tensor in fractional space</li>
<li><strong>u_cif</strong> – Anisotropic displacement tensor, dimensionless basis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cctbx.miller.array object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.deep_copy">
<code class="descname">deep_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the set, also copying the crystal symmetry and indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a set object with all-new attributes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.delete_index">
<code class="descname">delete_index</code><span class="sig-paren">(</span><em>hkl</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.delete_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all reflections with the specified Miller index.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.delete_indices">
<code class="descname">delete_indices</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.delete_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete multiple reflections, as specified by the Miller indices of
another set.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.epsilons">
<code class="descname">epsilons</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.epsilons" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.expand_to_p1">
<code class="descname">expand_to_p1</code><span class="sig-paren">(</span><em>return_iselection=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.expand_to_p1" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transformation of the miller set to spacegroup P1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new set of parameters (symmetry, miller indices, anomalous_flag) in spacegroup P1</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#cctbx.miller.set" title="cctbx.miller.set">set</a>(<a class="reference internal" href="cctbx.crystal.html#cctbx.crystal.symmetry" title="cctbx.crystal.symmetry">cctbx.crystal.symmetry</a>, cctbx.miller.indices, boolean)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.expand_to_p1_iselection">
<code class="descname">expand_to_p1_iselection</code><span class="sig-paren">(</span><em>build_iselection=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.expand_to_p1_iselection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.f_obs_minus_xray_structure_f_calc">
<code class="descname">f_obs_minus_xray_structure_f_calc</code><span class="sig-paren">(</span><em>f_obs_factor</em>, <em>xray_structure</em>, <em>structure_factor_algorithm=None</em>, <em>cos_sin_table=False</em>, <em>quality_factor=None</em>, <em>u_base=None</em>, <em>b_base=None</em>, <em>wing_cutoff=None</em>, <em>exp_table_one_over_step_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.f_obs_minus_xray_structure_f_calc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.first_index">
<code class="descname">first_index</code><span class="sig-paren">(</span><em>miller_index</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first index of the item  matching
<cite>miller_index</cite>. If the <cite>miller_index</cite> is not found in <cite>self</cite>,
then returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>miller_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a>) – Miller index as a 3-tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">int, None – index of first occurrence of
<cite>miller_index</cite> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.generate_r_free_flags">
<code class="descname">generate_r_free_flags</code><span class="sig-paren">(</span><em>fraction=0.1</em>, <em>max_free=2000</em>, <em>lattice_symmetry_max_delta=5.0</em>, <em>use_lattice_symmetry=True</em>, <em>use_dataman_shells=False</em>, <em>n_shells=20</em>, <em>format='cns'</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.generate_r_free_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array of R-free flags for the current set, keeping anomalous
pairs together.  Requires that the set already be unique under symmetry,
and generally assumes that the set is in the ASU.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fraction</strong> – fraction of reflections to flag for the test set</li>
<li><strong>max_free</strong> – limit on size of test set, overrides fraction</li>
<li><strong>lattice_symmetry_max_delta</strong> – limit on lattice symmetry calculation</li>
<li><strong>use_lattice_symmetry</strong> – given the current symmetry, determine the     highest possible lattice symmetry and generate flags for that symmetry,     then expand to the current (lower) symmetry if necessary.  This is almost     always a good idea.</li>
<li><strong>use_dataman_shells</strong> – generate flags in thin resolution shells to     avoid bias due to non-crystallographic symmetry.</li>
<li><strong>n_shells</strong> – number of resolution shells if use_dataman_shells=True</li>
<li><strong>format</strong> – convention of the resulting flags.  ‘cns’ will return a     boolean array (True = free), ‘ccp4’ will return an integer array from     0 to X (0 = free, X dependent on fraction), ‘shelx’ will return an     integer array with values 1 (work) or -1 (free).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a boolean or integer Miller array, depending on format.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.generate_r_free_flags_basic">
<code class="descname">generate_r_free_flags_basic</code><span class="sig-paren">(</span><em>fraction=0.1</em>, <em>max_free=2000</em>, <em>use_dataman_shells=False</em>, <em>n_shells=20</em>, <em>format='cns'</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.generate_r_free_flags_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate R-free flags, without taking lattice symmetry into account (not
recommended).  Should not normally be called directly - use
generate_r_free_flags(…) instead.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.generate_r_free_flags_on_lattice_symmetry">
<code class="descname">generate_r_free_flags_on_lattice_symmetry</code><span class="sig-paren">(</span><em>fraction=0.1</em>, <em>max_free=2000</em>, <em>max_delta=5.0</em>, <em>return_integer_array=False</em>, <em>n_partitions=None</em>, <em>use_dataman_shells=False</em>, <em>n_shells=20</em>, <em>format='cns'</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.generate_r_free_flags_on_lattice_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate R-free flags by converting to the highest possible lattice
symmetry (regardless of intensity symmetry), creating flags, and expanding
back to the original symmetry.  This is a safeguard against reflections
that are correlated due to twinning being split between the work and test
sets.</p>
<p>This method should usually not be called directly, but rather through
set.generate_r_free_flags(…).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.index_span">
<code class="descname">index_span</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.index_span" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.indices">
<code class="descname">indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the internal array of indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a cctbx.array_family.flex.miller_index array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.is_in_asu">
<code class="descname">is_in_asu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.is_in_asu" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate whether the array is entirely contained within the reciprocal
space asymmetric unit (ASU).  Warning: this calls map_to_asu internally,
so it is better to simply call map_to_asu without checking in many cases.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.is_unique_set_under_symmetry">
<code class="descname">is_unique_set_under_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.is_unique_set_under_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the indices in the set are symmetry-unique.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.log_binning">
<code class="descname">log_binning</code><span class="sig-paren">(</span><em>n_reflections_in_lowest_resolution_bin=100</em>, <em>eps=0.0001</em>, <em>max_number_of_bins=30</em>, <em>min_reflections_in_bin=50</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.log_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Create resolution bins on a logarithmic scale.  See Urzhumtsev et al.
(2009) Acta Crystallogr D Biol Crystallogr. 65:1283-91.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.lone_set">
<code class="descname">lone_set</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.lone_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the indices in the current set and another set, and return a set
(or array) containing reflections which are present only in the current
set.  Assumes that both sets are already in the asymmetric unit.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.lone_sets">
<code class="descname">lone_sets</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.lone_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Like lone_set(other), but returns a tuple containing the reflections
unique to each set (or array).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.map_to_asu">
<code class="descname">map_to_asu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.map_to_asu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all indices to lie within the canonical asymmetric unit for the
current space group (while preserving anomalous flag).  Required for many
downstream steps.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.match_bijvoet_mates">
<code class="descname">match_bijvoet_mates</code><span class="sig-paren">(</span><em>assert_is_unique_set_under_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.match_bijvoet_mates" title="Permalink to this definition">¶</a></dt>
<dd><p>Group Bijvoet mates (or Friedel mates) together, returning an object that
allows enumeration over matching pairs and/or singletons.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.match_indices">
<code class="descname">match_indices</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.match_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.miller_indices_as_pdb_file">
<code class="descname">miller_indices_as_pdb_file</code><span class="sig-paren">(</span><em>file_name=None</em>, <em>expand_to_p1=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.miller_indices_as_pdb_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out Miller indices as pseudo-waters for visualization.  Note that
this treats the indices as literal coordinates (times a scale factor),
and the distances between points will not correspond to the distances
in reciprocal space.</p>
<p>See cctbx/miller/display.py and crys3d/hklview for an alternative (but
less lightweight) approach.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.min_max_d_star_sq">
<code class="descname">min_max_d_star_sq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.min_max_d_star_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.min_max_indices">
<code class="descname">min_max_indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.min_max_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the range of h,k,l indices</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.minimum_wavelength_based_on_d_min">
<code class="descname">minimum_wavelength_based_on_d_min</code><span class="sig-paren">(</span><em>tolerance=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.minimum_wavelength_based_on_d_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.multiplicities">
<code class="descname">multiplicities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.multiplicities" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Miller array (with integer data) indicating the multiplicity of
each unique reflection.  (If the set or array is already symmetry-unique,
the multiplicity will be 1 for every reflection.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">array object with flex.int data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.n_bijvoet_pairs">
<code class="descname">n_bijvoet_pairs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.n_bijvoet_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of Bijvoet pairs.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.patterson_symmetry">
<code class="descname">patterson_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.patterson_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.random_phases_compatible_with_phase_restrictions">
<code class="descname">random_phases_compatible_with_phase_restrictions</code><span class="sig-paren">(</span><em>deg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.random_phases_compatible_with_phase_restrictions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.reflection_intensity_symmetry">
<code class="descname">reflection_intensity_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.reflection_intensity_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.remove_systematic_absences">
<code class="descname">remove_systematic_absences</code><span class="sig-paren">(</span><em>negate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.remove_systematic_absences" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.resolution_filter">
<code class="descname">resolution_filter</code><span class="sig-paren">(</span><em>d_max=0</em>, <em>d_min=0</em>, <em>negate=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.resolution_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a subset within the indicated resolution range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d_max</strong> – Low-resolution cutoff</li>
<li><strong>d_min</strong> – High-resolution cutoff</li>
<li><strong>negate</strong> – Select outside this range instead</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">set or array depending on object type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.resolution_filter_selection">
<code class="descname">resolution_filter_selection</code><span class="sig-paren">(</span><em>d_max=None</em>, <em>d_min=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.resolution_filter_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the selection (flex.bool array) corresponding to the specified
resolution range.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.resolution_range">
<code class="descname">resolution_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.resolution_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for d_max_min().</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>selection</em>, <em>negate=False</em>, <em>anomalous_flag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a subset of reflections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>selection</strong> – flex.bool or flex.size_t selection</li>
<li><strong>negate</strong> – select the inverse of the selection array</li>
<li><strong>anomalous_flag</strong> – anomalous flag for the new set</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new set with a subset of indices</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.select_acentric">
<code class="descname">select_acentric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.select_acentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only acentric reflections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Miller set or array (depending on object type).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.select_centric">
<code class="descname">select_centric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.select_centric" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only centric reflections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Miller set or array (depending on object type).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.setup_binner">
<code class="descname">setup_binner</code><span class="sig-paren">(</span><em>d_max=0</em>, <em>d_min=0</em>, <em>auto_binning=False</em>, <em>reflections_per_bin=0</em>, <em>n_bins=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.setup_binner" title="Permalink to this definition">¶</a></dt>
<dd><p>Create internal resolution binner object; required for many other methods
to work.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.setup_binner_counting_sorted">
<code class="descname">setup_binner_counting_sorted</code><span class="sig-paren">(</span><em>d_max=0</em>, <em>d_min=0</em>, <em>reflections_per_bin=None</em>, <em>n_bins=None</em>, <em>d_tolerance=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.setup_binner_counting_sorted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.setup_binner_d_star_sq_step">
<code class="descname">setup_binner_d_star_sq_step</code><span class="sig-paren">(</span><em>auto_binning=True</em>, <em>d_max=None</em>, <em>d_min=None</em>, <em>d_star_sq_step=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.setup_binner_d_star_sq_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.show_completeness">
<code class="descname">show_completeness</code><span class="sig-paren">(</span><em>reflections_per_bin=500</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.show_completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the completeness in resolution bins.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.show_comprehensive_summary">
<code class="descname">show_comprehensive_summary</code><span class="sig-paren">(</span><em>f=None</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.show_comprehensive_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Display comprehensive Miller set or array summary</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.show_summary">
<code class="descname">show_summary</code><span class="sig-paren">(</span><em>f=None</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.show_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimal Miller set summary</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sin_theta_over_lambda_sq">
<code class="descname">sin_theta_over_lambda_sq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.sin_theta_over_lambda_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.size">
<code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of reflections in the set or array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>axis=None</em>, <em>axis_index=None</em>, <em>slice_index=None</em>, <em>slice_start=None</em>, <em>slice_end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.slice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>by_value='resolution'</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder reflections by resolution or Miller index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>by_value</strong> – ‘resolution’ or ‘packed_indices’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sort_permutation">
<code class="descname">sort_permutation</code><span class="sig-paren">(</span><em>by_value='resolution'</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.sort_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the selection array (flex.size_t object) to reorder the array
by resolution or Miller index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>by_value</strong> – sort type, must be “resolution” or “packed_indices”</li>
<li><strong>reverse</strong> – invert order</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">flex.size_t object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.structure_factors_from_asu_map">
<code class="descname">structure_factors_from_asu_map</code><span class="sig-paren">(</span><em>asu_map_data</em>, <em>n_real</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.structure_factors_from_asu_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.structure_factors_from_map">
<code class="descname">structure_factors_from_map</code><span class="sig-paren">(</span><em>map</em>, <em>in_place_fft=False</em>, <em>use_scale=False</em>, <em>anomalous_flag=None</em>, <em>use_sg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.structure_factors_from_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Run FFT on a real-space map to calculate structure factors corresponding to
the current set of Miller indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>map</strong> – flex.double map with 3D flex.grid accessor</li>
<li><strong>in_place_fft</strong> – perform the FFT in place instead of creating a copy of
the map first</li>
<li><strong>use_scale</strong> – perform volume-scaling using current unit cell</li>
<li><strong>anomalous_flag</strong> – determines anomalous_flag for output array</li>
<li><strong>use_sg</strong> – use space-group symmetry</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array with same Miller indices and complex_double data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.structure_factors_from_scatterers">
<code class="descname">structure_factors_from_scatterers</code><span class="sig-paren">(</span><em>xray_structure</em>, <em>algorithm=None</em>, <em>cos_sin_table=False</em>, <em>grid_resolution_factor=0.3333333333333333</em>, <em>quality_factor=None</em>, <em>u_base=None</em>, <em>b_base=None</em>, <em>wing_cutoff=None</em>, <em>exp_table_one_over_step_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.structure_factors_from_scatterers" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate structure factors for an <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">cctbx.xray.structure</span></code></a> object
corresponding to the current set of Miller indices.  Can use either FFT
or direct summation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xray_structure</strong> – <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">cctbx.xray.structure</span></code></a> object</li>
<li><strong>algorithm</strong> – switch method to calculate structure factors - can be
‘direct’ or ‘fft’</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array with same Miller indices and complex_double data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sys_absent_flags">
<code class="descname">sys_absent_flags</code><span class="sig-paren">(</span><em>integral_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.sys_absent_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a boolean Miller array flagging those reflections which are
systematically absent under the current symmetry.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.two_theta">
<code class="descname">two_theta</code><span class="sig-paren">(</span><em>wavelength</em>, <em>deg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.two_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a double Miller array containing the scattering angle of each
index.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.unique_under_symmetry">
<code class="descname">unique_under_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.unique_under_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.unique_under_symmetry_selection">
<code class="descname">unique_under_symmetry_selection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.unique_under_symmetry_selection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.use_binner_of">
<code class="descname">use_binner_of</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.use_binner_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the exact binner of another set, which must have identical indices.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.use_binning">
<code class="descname">use_binning</code><span class="sig-paren">(</span><em>binning</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.use_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the resolution binning of the specified binner object (does not need
to be from an identically sized set).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.use_binning_of">
<code class="descname">use_binning_of</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.set.use_binning_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the resolution binning of the specified set (does not need to be an
identical set of indices).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cctbx.miller.build_set">
<code class="descclassname">cctbx.miller.</code><code class="descname">build_set</code><span class="sig-paren">(</span><em>crystal_symmetry</em>, <em>anomalous_flag</em>, <em>d_min=None</em>, <em>d_max=None</em>, <em>max_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.build_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Given crystal symmetry, anomalous flag, and resolution limits, create a
complete set object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>crystal_symmetry</strong> – cctbx.crystal.symmetry object</li>
<li><strong>anomalous_flag</strong> – Boolean, indicates whether to generate anomalous indices</li>
<li><strong>d_min</strong> – High-resolution limit (optional if max_index is specified)</li>
<li><strong>d_max</strong> – Low-resolution limit (optional)</li>
<li><strong>max_index</strong> – highest-resolution Miller index</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a set object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="the-miller-array">
<h2>The Miller array<a class="headerlink" href="#the-miller-array" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cctbx.miller.array">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">array</code><span class="sig-paren">(</span><em>miller_set</em>, <em>data=None</em>, <em>sigmas=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cctbx.miller.set" title="cctbx.miller.set"><code class="xref py py-class docutils literal notranslate"><span class="pre">cctbx.miller.set</span></code></a></p>
<p>Extension of the set class with addition of data and (optional) sigmas
flex arrays, plus an optional array_info object and an optional flag for
the observation type (amplitude, intensity, or reconstructed amplitude).</p>
<dl class="method">
<dt id="cctbx.miller.array.adopt_set">
<code class="descname">adopt_set</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.adopt_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.amplitude_normalisations">
<code class="descname">amplitude_normalisations</code><span class="sig-paren">(</span><em>asu_contents</em>, <em>wilson_plot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.amplitude_normalisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Overriden version of set.amplitude_normalisation which computes
the Wilson parameters from the array data if wilson_plot is None.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.amplitude_quasi_normalisations">
<code class="descname">amplitude_quasi_normalisations</code><span class="sig-paren">(</span><em>d_star_power=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.amplitude_quasi_normalisations" title="Permalink to this definition">¶</a></dt>
<dd><p>A miller.array whose data N(h) are the normalisations to convert
between locally normalised E’s and F’s:
E(h) = F(h) / N(h)</p>
<p>self features the F’s, which are then binned with the current binner
and N(h) is the average of F’s in the bin h belongs to.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.amplitudes">
<code class="descname">amplitudes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>For a complex array, return array of absolute values.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.analyze_intensity_statistics">
<code class="descname">analyze_intensity_statistics</code><span class="sig-paren">(</span><em>d_min=2.5</em>, <em>completeness_as_non_anomalous=None</em>, <em>log=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.analyze_intensity_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect translational pseudosymmetry and twinning, using methods in
Xtriage.  Returns a mmtbx.scaling.twin_analyses.twin_law_interpretation
object.  (Requires mmtbx to be configured to be functional.)</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.anomalous_completeness">
<code class="descname">anomalous_completeness</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>d_min_tolerance=1e-06</em>, <em>d_max=None</em>, <em>d_min=None</em>, <em>relative_to_complete_set=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.anomalous_completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the percent of acentric reflections with both h,k,l and -h,-k,-l
observed (only meaningful for amplitude and intensity arrays).  By default
this is calculated relative to the complete set.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.anomalous_differences">
<code class="descname">anomalous_differences</code><span class="sig-paren">(</span><em>enforce_positive_sigmas=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.anomalous_differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array object with DANO (i.e. F(+) - F(-)) as data, and
optionally SIGDANO as sigmas.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.anomalous_signal">
<code class="descname">anomalous_signal</code><span class="sig-paren">(</span><em>use_binning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.anomalous_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the anomalous signal according to this formula:</p>
<div class="math notranslate nohighlight">
\[\sqrt{\dfrac{&lt;||F(+)|-|F(-)||^2&gt;}{\frac{1}{2} (&lt;|F(+)|&gt;^2 + &lt;|F(-)|&gt;^2)}}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>use_binning</strong> (<em>boolean</em>) – If ‘True’ the anomalous signal will be calculated for     each bin of the data set individually</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the anomalous signal</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.float" title="scitbx.array_family.flex.float">float</a> or cctbx.miller.binned_data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_change_of_basis">
<code class="descname">apply_change_of_basis</code><span class="sig-paren">(</span><em>change_of_basis</em>, <em>eliminate_invalid_indices=True</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.apply_change_of_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates a variety of reindexing operations, including handling for a
variety of corner cases.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>change_of_basis</strong> – Python str for change-of-basis operator</li>
<li><strong>eliminate_invalid_indices</strong> – remove reflections with non-integral
indices</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new Miller array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_debye_waller_factors">
<code class="descname">apply_debye_waller_factors</code><span class="sig-paren">(</span><em>u_iso=None</em>, <em>b_iso=None</em>, <em>u_cart=None</em>, <em>b_cart=None</em>, <em>u_cif=None</em>, <em>u_star=None</em>, <em>apply_to_sigmas=True</em>, <em>exp_arg_limit=50</em>, <em>truncate_exp_arg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.apply_debye_waller_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an isotropic or anisotropic displacement or B-factor, apply
resolution-dependent scale factors to the data (and optionally sigmas).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u_iso</strong> – Isotropic displacement (in Angstroms)</li>
<li><strong>b_iso</strong> – Isotropic B-factor (8*pi^2*u_iso^2)</li>
<li><strong>u_cart</strong> – Anisotropic displacement tensor</li>
<li><strong>b_cart</strong> – Anisotropic B-factor</li>
<li><strong>u_star</strong> – Anisotropic displacement tensor in fractional space</li>
<li><strong>u_cif</strong> – Anisotropic displacement tensor, dimensionless basis</li>
<li><strong>apply_to_sigmas</strong> – Also scale sigma values (if present)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cctbx.miller.array object with scaled data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_scaling">
<code class="descname">apply_scaling</code><span class="sig-paren">(</span><em>target_max=None</em>, <em>factor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.apply_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a scale factor to the data (and optionally sigmas).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>target_max</strong> – target maximum value for the scaled data - the scale
factor will be determined automatically</li>
<li><strong>factor</strong> – explicit scale factor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">custumozed copy with scaled data and sigmas</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_shelxl_extinction_correction">
<code class="descname">apply_shelxl_extinction_correction</code><span class="sig-paren">(</span><em>x</em>, <em>wavelength</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.apply_shelxl_extinction_correction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.arg">
<code class="descname">arg</code><span class="sig-paren">(</span><em>deg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_amplitude_array">
<code class="descname">as_amplitude_array</code><span class="sig-paren">(</span><em>algorithm='xtal_3_7'</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_amplitude_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the array to simple amplitudes if not already in that format.
Only valid for complex (i.e. F,PHI), intensity, or amplitude arrays.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_anomalous_array">
<code class="descname">as_anomalous_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_anomalous_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array with identical contents (keeping original
flex arrays) but with the anomalous flag set to true.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_cif_block">
<code class="descname">as_cif_block</code><span class="sig-paren">(</span><em>array_type</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_cif_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_cif_simple">
<code class="descname">as_cif_simple</code><span class="sig-paren">(</span><em>array_type</em>, <em>out=None</em>, <em>data_name='global'</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_cif_simple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_double">
<code class="descname">as_double</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_double" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the array with the data converted to a flex.double type.
Will fail for incompatible arrays.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_intensity_array">
<code class="descname">as_intensity_array</code><span class="sig-paren">(</span><em>algorithm='simple'</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_intensity_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the array to intensities if not already in that format.  Only valid
for complex (F,PHI), amplitude, or intensity arrays.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_mtz_dataset">
<code class="descname">as_mtz_dataset</code><span class="sig-paren">(</span><em>column_root_label</em>, <em>column_types=None</em>, <em>label_decorator=None</em>, <em>title=None</em>, <em>crystal_name='crystal'</em>, <em>project_name='project'</em>, <em>dataset_name='dataset'</em>, <em>wavelength=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_mtz_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an iotbx.mtz.dataset object for the array, which can be extended
with additional arrays and eventually written to an MTZ file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_non_anomalous_array">
<code class="descname">as_non_anomalous_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_non_anomalous_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array with identical contents (keeping original
flex arrays) but with the anomalous flag set to false.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_phases_phs">
<code class="descname">as_phases_phs</code><span class="sig-paren">(</span><em>out</em>, <em>scale_amplitudes=True</em>, <em>phases=None</em>, <em>phases_deg=None</em>, <em>figures_of_merit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_phases_phs" title="Permalink to this definition">¶</a></dt>
<dd><p>Write phases to .phs file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_xray_observations">
<code class="descname">as_xray_observations</code><span class="sig-paren">(</span><em>scale_indices=None</em>, <em>twin_fractions=None</em>, <em>twin_components=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.as_xray_observations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.average_bijvoet_mates">
<code class="descname">average_bijvoet_mates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.average_bijvoet_mates" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an anomalous array, merge the anomalous pairs and return the
non-anomalous average.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.average_neighbors">
<code class="descname">average_neighbors</code><span class="sig-paren">(</span><em>layers=1</em>, <em>include_origin=False</em>, <em>offset_list=None</em>, <em>average_with_cc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.average_neighbors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.bijvoet_ratios">
<code class="descname">bijvoet_ratios</code><span class="sig-paren">(</span><em>obs_type='intensity'</em>, <em>measurable_only=True</em>, <em>cutoff=3.0</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.bijvoet_ratios" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.cc_anom">
<code class="descname">cc_anom</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.cc_anom" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for array.half_dataset_anomalous_correlation()</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.cc_one_half">
<code class="descname">cc_one_half</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>n_trials=1</em>, <em>anomalous_flag=False</em>, <em>return_n_refl=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.cc_one_half" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation between two randomly assigned pools of unmerged
data (“CC 1/2”).  If desired the mean over multiple trials can be taken.
See Karplus PA &amp; Diederichs K (2012) Science 336:1030-3 for motivation.
This method assumes that the reflections still have the original indices
and maps them to the ASU first; the underlying compute_cc_one_half
function skips this method.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.cc_one_half_sigma_tau">
<code class="descname">cc_one_half_sigma_tau</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>return_n_refl=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.cc_one_half_sigma_tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of CC1/2 by the ‘sigma-tau’ method, avoiding the random
assignment into half-datasets of the above method.
See Assmann et al., J. Appl. Cryst. (2016). 49, 1021–1028.</p>
<p>var_y is the variange of the average intensities across the unique
reflections of a resolution shell.
var_e is the average variance of the observations contributing to the
merged intensities</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.change_basis">
<code class="descname">change_basis</code><span class="sig-paren">(</span><em>cb_op</em>, <em>deg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.change_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transformation of the miller set with a new basis specified by cb_op</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cb_op</strong> (<em>string</em><em> or </em><em>sgtbx.change_of_basis_operator</em>) – object describing the desired transformation of the basis</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a new miller set with the new basis</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#cctbx.miller.set" title="cctbx.miller.set">cctbx.miller.set</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.change_symmetry">
<code class="descname">change_symmetry</code><span class="sig-paren">(</span><em>space_group_symbol=None</em>, <em>space_group_info=None</em>, <em>volume_warning_threshold=0.001</em>, <em>expand_to_p1_if_necessary=True</em>, <em>remove_systematic_absences=True</em>, <em>merge_non_unique=True</em>, <em>log=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.change_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates all operations required to convert the original data to a
different symmetry (e.g. as suggested by Xtriage).  This includes
reindexing and adjusting the unit cell parameters if necessary, and
expansion to P1 (for moving to lower symmetry) or merging equivalents.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>space_group_symbol</strong> – Python str for space group symbol (any format)</li>
<li><strong>space_group_info</strong> – Pre-defined sgtbx.space_group_info object</li>
<li><strong>volume_warning_threshold</strong> – Cutoff for relative change in unit cell
volume beyond which a warning is issued.</li>
<li><strong>expand_to_p1_if_necessary</strong> – When moving to lower symmetry, expand the
data to P1 first.</li>
<li><strong>remove_systematic_absences</strong> – eliminate reflections that are
systematically absent in the new symmetry.</li>
<li><strong>merge_non_unique</strong> – merge reflections that are no longer symmetry-
unique under the new symmetry.</li>
<li><strong>log</strong> – filehandle-like object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Miller array in the new symmetry</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.combine">
<code class="descname">combine</code><span class="sig-paren">(</span><em>other</em>, <em>scale=True</em>, <em>scale_for_lones=1</em>, <em>scale_for_matches=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.combine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.complete_array">
<code class="descname">complete_array</code><span class="sig-paren">(</span><em>d_min_tolerance=1e-06</em>, <em>d_min=None</em>, <em>d_max=None</em>, <em>new_data_value=-1</em>, <em>new_sigmas_value=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.complete_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.complete_with">
<code class="descname">complete_with</code><span class="sig-paren">(</span><em>other</em>, <em>scale=False</em>, <em>replace_phases=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.complete_with" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.complete_with_bin_average">
<code class="descname">complete_with_bin_average</code><span class="sig-paren">(</span><em>reflections_per_bin=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.complete_with_bin_average" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.concatenate">
<code class="descname">concatenate</code><span class="sig-paren">(</span><em>other</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two Miller sets.  Both must have the same anomalous flag, and
similar symmetry is also assumed.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.convert_to_non_anomalous_if_ratio_pairs_lone_less_than">
<code class="descname">convert_to_non_anomalous_if_ratio_pairs_lone_less_than</code><span class="sig-paren">(</span><em>threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.convert_to_non_anomalous_if_ratio_pairs_lone_less_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anomalous array into nonanomalous if the number of Bijvoet pairs is
too small compared to the number of lone Bijvoet mates.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new array object using references to internal objects.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.correlation">
<code class="descname">correlation</code><span class="sig-paren">(</span><em>other</em>, <em>use_binning=False</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate correlation coefficient between two arrays (either globally or
binned).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> – another array of real numbers</li>
<li><strong>use_binning</strong> – calculate CC in resolution bins (default = calculate
a single global value)</li>
<li><strong>assert_is_similar_symmetry</strong> – check that arrays have compatible
crystal symmetry</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Python float (if use_binning=False), or a binned_data object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.count_and_fraction_in_bins">
<code class="descname">count_and_fraction_in_bins</code><span class="sig-paren">(</span><em>data_value_to_count</em>, <em>count_not_equal=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.count_and_fraction_in_bins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.crystal_symmetry_is_compatible_with_symmetry_from_file">
<code class="descname">crystal_symmetry_is_compatible_with_symmetry_from_file</code><span class="sig-paren">(</span><em>unit_cell_relative_length_tolerance=0.02</em>, <em>unit_cell_absolute_angle_tolerance=3.0</em>, <em>working_point_group=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.crystal_symmetry_is_compatible_with_symmetry_from_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.customized_copy">
<code class="descname">customized_copy</code><span class="sig-paren">(</span><em>miller_set=Keep</em>, <em>data=Keep</em>, <em>sigmas=Keep</em>, <em>crystal_symmetry=Keep</em>, <em>indices=Keep</em>, <em>anomalous_flag=Keep</em>, <em>unit_cell=Keep</em>, <em>space_group_info=Keep</em>, <em>observation_type=Keep</em>, <em>info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.customized_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the set, optionally changing the symmetry, indices,
and/or anomalous flag (default = keep all unmodified).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.d_min_from_fsc">
<code class="descname">d_min_from_fsc</code><span class="sig-paren">(</span><em>other=None</em>, <em>fsc_curve=None</em>, <em>bin_width=1000</em>, <em>fsc_cutoff=0.143</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.d_min_from_fsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Fourier Shell Correlation (FSC) and derive resolution based on
specified cutoff.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.data">
<code class="descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.data_at_first_index">
<code class="descname">data_at_first_index</code><span class="sig-paren">(</span><em>miller_index</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.data_at_first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of data of the first index matching
<cite>miller_index</cite>. If the <cite>miller_index</cite> is not found in <cite>self</cite>,
then returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>miller_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a>) – Miller index as a 3-tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">int, float, complex, None – data value or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.deep_copy">
<code class="descname">deep_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone the array, making copies of all internal array objects.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.detwin_data">
<code class="descname">detwin_data</code><span class="sig-paren">(</span><em>twin_law</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.detwin_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Detwin data using a known twin fraction, returning an array with the same
original data type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Params twin_law:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">a valid twin law expressed as h,k,l operations</td>
</tr>
<tr class="field-even field"><th class="field-name">Params alpha:</th><td class="field-body">predicted twin fraction (0 to 0.5)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new array with detwinned data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.direct_summation_at_point">
<code class="descname">direct_summation_at_point</code><span class="sig-paren">(</span><em>site_frac</em>, <em>sigma=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.direct_summation_at_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the exact map value at the specified fractional coordinate
using direct Fourier summation.  Relatively slow but avoids interpolation
errors.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.disagreeable_reflections">
<code class="descname">disagreeable_reflections</code><span class="sig-paren">(</span><em>f_calc_sq</em>, <em>n_reflections=20</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.disagreeable_reflections" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.discard_sigmas">
<code class="descname">discard_sigmas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.discard_sigmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the array without sigmas.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.double_step_filtration">
<code class="descname">double_step_filtration</code><span class="sig-paren">(</span><em>complete_set=None</em>, <em>vol_cutoff_plus_percent=5.0</em>, <em>vol_cutoff_minus_percent=5.0</em>, <em>resolution_factor=0.25</em>, <em>scale_to=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.double_step_filtration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.eliminate_sys_absent">
<code class="descname">eliminate_sys_absent</code><span class="sig-paren">(</span><em>integral_only=False</em>, <em>log=None</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.eliminate_sys_absent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all reflections which should be systematically absent in the current
space group.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.ellipsoidal_resolutions_and_indices_by_sigma">
<code class="descname">ellipsoidal_resolutions_and_indices_by_sigma</code><span class="sig-paren">(</span><em>sigma_cutoff=3</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.ellipsoidal_resolutions_and_indices_by_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.ellipsoidal_truncation_by_sigma">
<code class="descname">ellipsoidal_truncation_by_sigma</code><span class="sig-paren">(</span><em>sigma_cutoff=3</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.ellipsoidal_truncation_by_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.enforce_positive_amplitudes">
<code class="descname">enforce_positive_amplitudes</code><span class="sig-paren">(</span><em>i_sig_level=-4.0</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.enforce_positive_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes in an intensity array (including negatives) and spits out amplitudes.
The basic assumption is that
P(Itrue) propto exp(-(Itrue-Iobs)**2/(2*s))
where Itrue&gt;=0 (positivity constraint on error free amplitudes).
For amplitudes, this results in
P(Ftrue) propto 2 Ftrue exp( -(Ftrue**2-Iobs)**2/(2s) )
A Gaussian approximation is fitted to the Mode of this distribution.
An analytical solution exists and is implemented below.
This method does not require any Wilson statistics assumptions.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.enforce_positive_sigmas">
<code class="descname">enforce_positive_sigmas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.enforce_positive_sigmas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.expand_to_p1">
<code class="descname">expand_to_p1</code><span class="sig-paren">(</span><em>phase_deg=None</em>, <em>return_iselection=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.expand_to_p1" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the equivalent P1 dataset.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.export_as_cns_hkl">
<code class="descname">export_as_cns_hkl</code><span class="sig-paren">(</span><em>file_object</em>, <em>file_name=None</em>, <em>info=[]</em>, <em>array_names=None</em>, <em>r_free_flags=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.export_as_cns_hkl" title="Permalink to this definition">¶</a></dt>
<dd><p>Write reflections to a CNS-format file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.export_as_scalepack_unmerged">
<code class="descname">export_as_scalepack_unmerged</code><span class="sig-paren">(</span><em>file_object=None</em>, <em>file_name=None</em>, <em>batch_numbers=None</em>, <em>spindle_flags=None</em>, <em>scale_intensities_for_scalepack_merge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.export_as_scalepack_unmerged" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in unmerged scalepack format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_object</strong> – filehandle-like object</li>
<li><strong>file_name</strong> – output file to write</li>
<li><strong>batch_numbers</strong> – integer array indicating the batch (image) numbers
corresponding to the indices (optional)</li>
<li><strong>spindle_flags</strong> – integer array indicating the position of the
reflections on the detector (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.export_as_shelx_hklf">
<code class="descname">export_as_shelx_hklf</code><span class="sig-paren">(</span><em>file_object=None</em>, <em>normalise_if_format_overflow=False</em>, <em>full_dynamic_range=False</em>, <em>scale_range=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.export_as_shelx_hklf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write reflections to a SHELX-format .hkl file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_as_f_sq">
<code class="descname">f_as_f_sq</code><span class="sig-paren">(</span><em>algorithm='simple'</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.f_as_f_sq" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert amplitudes (and associated sigmas, if present) to intensities.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_obs_f_calc_fan_outlier_selection">
<code class="descname">f_obs_f_calc_fan_outlier_selection</code><span class="sig-paren">(</span><em>f_calc</em>, <em>offset_low=0.05</em>, <em>offset_high=0.1</em>, <em>also_return_x_and_y=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.f_obs_f_calc_fan_outlier_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Preconditions (not checked explicitly):
self is amplitude array,
f_calc is complex array or amplitude array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_obs_minus_f_calc">
<code class="descname">f_obs_minus_f_calc</code><span class="sig-paren">(</span><em>f_obs_factor</em>, <em>f_calc</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.f_obs_minus_f_calc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_sq_as_f">
<code class="descname">f_sq_as_f</code><span class="sig-paren">(</span><em>algorithm='xtal_3_7'</em>, <em>tolerance=1e-06</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.f_sq_as_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an intensity/F^2 array (or undefined observation type), return the
equivalent amplitudes.  Note that negative intensities will be discarded;
for French-Wilson treatment, call the separate array.french_wilson()
method.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.fft_map">
<code class="descname">fft_map</code><span class="sig-paren">(</span><em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>grid_step=None</em>, <em>crystal_gridding=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em>, <em>f_000=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.fft_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the FFT for the array, assuming the data are complex doubles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>resolution_factor</strong> – when multiplied times the resolution limit, gives
the approximate grid spacing of the map.</li>
<li><strong>d_min</strong> – High-resolution cutoff</li>
<li><strong>crystal_gridding</strong> – optional gridding to use (overrides automatic
gridding)</li>
<li><strong>symmetry_flags</strong> – specifies how the grid should be constructed to
handle symmetry</li>
<li><strong>f_000</strong> – Optional F(0,0,0) value (scalar added to entire map)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an fft_map object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.french_wilson">
<code class="descname">french_wilson</code><span class="sig-paren">(</span><em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.french_wilson" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform French-Wilson treatment of X-ray intensities to estimate the “true”
intensities, replacing very weak and/or negative values, and takes the
square root to obtain amplitudes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array of all-positive X-ray amplitudes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="cctbx.miller.array.from_cif">
<em class="property">classmethod </em><code class="descname">from_cif</code><span class="sig-paren">(</span><em>file_object=None</em>, <em>file_path=None</em>, <em>data_block_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.from_cif" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method for building an array from a CIF file (or filehandle).
Depends on iotbx.cif.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.fsc">
<code class="descname">fsc</code><span class="sig-paren">(</span><em>other</em>, <em>bin_width=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.fsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Fourier Shell Correlation (FSC)</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.generate_bijvoet_mates">
<code class="descname">generate_bijvoet_mates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.generate_bijvoet_mates" title="Permalink to this definition">¶</a></dt>
<dd><p>If the array is not already anomalous, expand to generate anomalous pairs
(without changing data).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.half_dataset_anomalous_correlation">
<code class="descname">half_dataset_anomalous_correlation</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>return_n_pairs=False</em>, <em>return_split_datasets=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.half_dataset_anomalous_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation of the anomalous differences of two randomly
assigned half-datasets (starting from unmerged data).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.has_twinning">
<code class="descname">has_twinning</code><span class="sig-paren">(</span><em>d_min=2.5</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.has_twinning" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method for identifying twinned data.  Note that this is
hugely inefficient if any other Xtriage analyses are planned, since it
discards the other results.  Requires mmtbx.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.hemisphere_acentrics">
<code class="descname">hemisphere_acentrics</code><span class="sig-paren">(</span><em>plus_or_minus</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.hemisphere_acentrics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.hemispheres_acentrics">
<code class="descname">hemispheres_acentrics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.hemispheres_acentrics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.hoppe_gassmann_modification">
<code class="descname">hoppe_gassmann_modification</code><span class="sig-paren">(</span><em>mean_scale</em>, <em>n_iterations</em>, <em>resolution_factor=0.25</em>, <em>d_min=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.hoppe_gassmann_modification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.i_over_sig_i">
<code class="descname">i_over_sig_i</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>return_fail=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.i_over_sig_i" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;I/sigma_I&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.info">
<code class="descname">info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the associated info object, or None if undefined.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.intensities">
<code class="descname">intensities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.intensities" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.intensity_quasi_normalisations">
<code class="descname">intensity_quasi_normalisations</code><span class="sig-paren">(</span><em>d_star_power=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.intensity_quasi_normalisations" title="Permalink to this definition">¶</a></dt>
<dd><p>A miller.array whose data N(h) are the normalisations to convert
between locally normalised E^2’s and I’s:
E^2(h) = I(h) / N(h)</p>
<p>Intensities are binned with the current binner
and N(h) is the average of I’s in the bin h belongs to.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_bool_array">
<code class="descname">is_bool_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_bool_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_complex_array">
<code class="descname">is_complex_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_complex_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_hendrickson_lattman_array">
<code class="descname">is_hendrickson_lattman_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_hendrickson_lattman_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_integer_array">
<code class="descname">is_integer_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_integer_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_real_array">
<code class="descname">is_real_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_real_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_string_array">
<code class="descname">is_string_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_string_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_unmerged_intensity_array">
<code class="descname">is_unmerged_intensity_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_unmerged_intensity_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the array contains unmerged experimental observations
or not.  In some files only the centric reflections will appear to be
unmerged, so we specifically check the acentrics (if present).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_amplitude_array">
<code class="descname">is_xray_amplitude_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_xray_amplitude_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_data_array">
<code class="descname">is_xray_data_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_xray_data_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_intensity_array">
<code class="descname">is_xray_intensity_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_xray_intensity_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_reconstructed_amplitude_array">
<code class="descname">is_xray_reconstructed_amplitude_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.is_xray_reconstructed_amplitude_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.local_overlap_map">
<code class="descname">local_overlap_map</code><span class="sig-paren">(</span><em>other</em>, <em>radius</em>, <em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>grid_step=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em>, <em>f_000=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.local_overlap_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.local_standard_deviation_map">
<code class="descname">local_standard_deviation_map</code><span class="sig-paren">(</span><em>radius</em>, <em>mean_solvent_density=0</em>, <em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>grid_step=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em>, <em>f_000=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.local_standard_deviation_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.map_correlation">
<code class="descname">map_correlation</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.map_correlation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.map_to_asu">
<code class="descname">map_to_asu</code><span class="sig-paren">(</span><em>deg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.map_to_asu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all indices to lie within the canonical asymmetric unit for the
current space group (while preserving anomalous flag).  Required for many
downstream steps.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.matching_set">
<code class="descname">matching_set</code><span class="sig-paren">(</span><em>other</em>, <em>data_substitute</em>, <em>sigmas_substitute=None</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.matching_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>use_multiplicities=False</em>, <em>squared=False</em>, <em>rms=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_of_intensity_divided_by_epsilon">
<code class="descname">mean_of_intensity_divided_by_epsilon</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>return_fail=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.mean_of_intensity_divided_by_epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;I/epsilon&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_of_squared_sigma_divided_by_epsilon">
<code class="descname">mean_of_squared_sigma_divided_by_epsilon</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>return_fail=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.mean_of_squared_sigma_divided_by_epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;sigma^2/epsilon&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_phase_error">
<code class="descname">mean_phase_error</code><span class="sig-paren">(</span><em>phase_source</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.mean_phase_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_sq">
<code class="descname">mean_sq</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>use_multiplicities=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.mean_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_weighted_phase_error">
<code class="descname">mean_weighted_phase_error</code><span class="sig-paren">(</span><em>phase_source</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.mean_weighted_phase_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.measurability">
<code class="descname">measurability</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>cutoff=3.0</em>, <em>return_fail=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.measurability" title="Permalink to this definition">¶</a></dt>
<dd><p>Fraction of reflections for which
(<span class="math notranslate nohighlight">\(\dfrac{|\Delta I|}{\sigma_{dI}}\)</span> &gt; cutoff and
<span class="math notranslate nohighlight">\(min(\dfrac{I_{+}}{\sigma_{+}},\dfrac{I_{-}}{\sigma_{-}})\)</span> &gt; cutoff</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.merge_equivalents">
<code class="descname">merge_equivalents</code><span class="sig-paren">(</span><em>algorithm='gaussian'</em>, <em>incompatible_flags_replacement=None</em>, <em>use_internal_variance=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.merge_equivalents" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a non-unique array, merge the symmetry-related reflections (keeping
anomalous flag).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a merge_equivalents object, from which the merged array may     be extracted by calling the array() method.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.min_f_over_sigma">
<code class="descname">min_f_over_sigma</code><span class="sig-paren">(</span><em>return_none_if_zero_sigmas=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.min_f_over_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.multiscale">
<code class="descname">multiscale</code><span class="sig-paren">(</span><em>other</em>, <em>reflections_per_bin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.multiscale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.norm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.normalised_amplitudes">
<code class="descname">normalised_amplitudes</code><span class="sig-paren">(</span><em>asu_contents</em>, <em>wilson_plot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.normalised_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>reflections_per_bin=150</em>, <em>eps_fac=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute E-values: E = (F/eps**0.5) / rms of (F/eps**0.5)
This is ‘Karle’ approach, that is not using overall B from Wilson plot.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.observation_type">
<code class="descname">observation_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.observation_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (experimental) data type, if defined.  See the module
cctbx.xray.observation_types for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an object from cctbx.xray.observation_types</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.patterson_map">
<code class="descname">patterson_map</code><span class="sig-paren">(</span><em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em>, <em>f_000=None</em>, <em>sharpening=False</em>, <em>origin_peak_removal=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.patterson_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate an unphased Patterson map.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.patterson_symmetry">
<code class="descname">patterson_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.patterson_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.permute_d_range">
<code class="descname">permute_d_range</code><span class="sig-paren">(</span><em>d_max</em>, <em>d_min</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.permute_d_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly shuffle reflections within a given resolution range.  Used for
control refinements to validate the information content of a dataset.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phase_entropy">
<code class="descname">phase_entropy</code><span class="sig-paren">(</span><em>exponentiate=False</em>, <em>return_binned_data=False</em>, <em>return_mean=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.phase_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get phase entropy as measured in terms of an base-360 entropy
(base-2 for centrics).</p>
<p>An entropy of 0, indicates that the phase uncertainity is as low as possible
An entropy of 1 however, indicates that the uncertainty is maximal:
all phases are equally likely!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>return_binned_data</strong> (<em>boolean</em>) – if ‘True’ you receive a binned object rather     then a raw array</li>
<li><strong>exponentiate</strong> (<em>boolean</em>) – whether or not to exponentiate the entropy. This will     return a phase uncertainty in degrees (or the ‘alphabet size’)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phase_integrals">
<code class="descname">phase_integrals</code><span class="sig-paren">(</span><em>n_steps=None</em>, <em>integrator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.phase_integrals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phase_transfer">
<code class="descname">phase_transfer</code><span class="sig-paren">(</span><em>phase_source</em>, <em>epsilon=1e-10</em>, <em>deg=False</em>, <em>phase_integrator_n_steps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.phase_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines phases of phase_source with self’s data if real (keeping
the sign of self’s data) or with self’s amplitudes if complex.</p>
<p>Centric reflections are forced to be compatible with the phase restrictions.</p>
<p>phase_source can be a miller.array or a plain flex array.</p>
<p>epsilon is only used when phase_source is a complex array. If both the
real and the imaginary part of phase_source[i] &lt; epsilon the phase is
assumed to be 0.</p>
<p>deg is only used if phase_source is an array of doubles.
deg=True indicates that the phases are given in degrees,
deg=False indicates phases are given in radians.</p>
<p>phase_integrator_n_steps is only used if phase_source is an
array of Hendrickson-Lattman coefficients. The centroid
phases are determined on the fly using the given step size.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phased_translation_function_coeff">
<code class="descname">phased_translation_function_coeff</code><span class="sig-paren">(</span><em>phase_source</em>, <em>f_calc</em>, <em>fom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.phased_translation_function_coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phases">
<code class="descname">phases</code><span class="sig-paren">(</span><em>deg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.phases" title="Permalink to this definition">¶</a></dt>
<dd><p>For a complex array, return the array of its phases (in radians by default).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.quasi_normalize_structure_factors">
<code class="descname">quasi_normalize_structure_factors</code><span class="sig-paren">(</span><em>d_star_power=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.quasi_normalize_structure_factors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.quasi_normalized_as_normalized">
<code class="descname">quasi_normalized_as_normalized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.quasi_normalized_as_normalized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.r1_factor">
<code class="descname">r1_factor</code><span class="sig-paren">(</span><em>other</em>, <em>scale_factor=None</em>, <em>assume_index_matching=False</em>, <em>use_binning=False</em>, <em>emulate_sftools=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.r1_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the R1 factor according to this formula</p>
<div class="math notranslate nohighlight">
\[R1 = \dfrac{\sum{||F| - k|F'||}}{\sum{|F|}}\]</div>
<p>where F is self.data() and F’ is other.data() and
k is the factor to put F’ on the same scale as F</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> – array object with the same observation type</li>
<li><strong>scale_factor</strong> – optional scale factor to be applied to ‘other’; if
Auto, will be determined automatically</li>
<li><strong>assume_index_matching</strong> – skips calling self.common_sets(other)</li>
<li><strong>use_binning</strong> – divide by resolution shells</li>
<li><strong>emulate_sftools</strong> – copies behavior of SFTOOLS in CCP4: instead of
the denominator being sum(self.data()), it will be 0.5*sum(self.data()+
other.data())</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Python float (if use_binning=False), or a binned_data object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.r_anom">
<code class="descname">r_anom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.r_anom" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate R_anom, which measures the agreement between Friedel mates.
Unlike CC_anom and various other R-factors (such as R_pim, which it is
usually compared to), this requires merged data.</p>
<div class="math notranslate nohighlight">
\[R_{anom} = \dfrac{\sum_{hkl}{|I_{hkl} - I_{-h,-k,-l}|}}{\sum_{hkl}{\left \langle I_{hkl} \right \rangle}}\]</div>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.r_free_flags_accumulation">
<code class="descname">r_free_flags_accumulation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.r_free_flags_accumulation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.randomize_amplitude_and_phase">
<code class="descname">randomize_amplitude_and_phase</code><span class="sig-paren">(</span><em>amplitude_error</em>, <em>phase_error_deg</em>, <em>selection=None</em>, <em>random_seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.randomize_amplitude_and_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Add random error to reflections.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.randomize_phases">
<code class="descname">randomize_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.randomize_phases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.remove_cone">
<code class="descname">remove_cone</code><span class="sig-paren">(</span><em>fraction_percent</em>, <em>vertex=(0</em>, <em>0</em>, <em>0)</em>, <em>axis_point_1=(0</em>, <em>0</em>, <em>0)</em>, <em>axis_point_2=(0</em>, <em>0</em>, <em>1)</em>, <em>negate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.remove_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove reflections corresponding to a cone shape in reciprocal space with
the apex at the origin.  Used to simulate incomplete data due to poor
alignment of the crystal with the goniometer axis.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.remove_patterson_origin_peak">
<code class="descname">remove_patterson_origin_peak</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.remove_patterson_origin_peak" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>use_multiplicities=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.rms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.rms_filter">
<code class="descname">rms_filter</code><span class="sig-paren">(</span><em>cutoff_factor</em>, <em>use_binning=False</em>, <em>use_multiplicities=False</em>, <em>negate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.rms_filter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>other</em>, <em>resolution_dependent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.scale_factor">
<code class="descname">scale_factor</code><span class="sig-paren">(</span><em>f_calc</em>, <em>weights=None</em>, <em>cutoff_factor=None</em>, <em>use_binning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.scale_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytical expression for the least squares scale factor.</p>
<p>K = sum(w * yo * yc) / sum(w * yc^2)</p>
<p>If the optional cutoff_factor argument is provided, only the reflections
whose magnitudes are greater than cutoff_factor * max(yo) will be included
in the calculation.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.second_moment">
<code class="descname">second_moment</code><span class="sig-paren">(</span><em>use_binning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.second_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;data^2&gt;/(&lt;data&gt;)^2</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.second_moment_of_intensities">
<code class="descname">second_moment_of_intensities</code><span class="sig-paren">(</span><em>use_binning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.second_moment_of_intensities" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;I^2&gt;/(&lt;I&gt;)^2 (2.0 for untwinned, 1.5 for twinned data)</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.second_moments_centric_acentric">
<code class="descname">second_moments_centric_acentric</code><span class="sig-paren">(</span><em>reflections_per_bin=150</em>, <em>eps_fac=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.second_moments_centric_acentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute &lt;E**4&gt;/&lt;E**2&gt;**2 for centric and acentric reflections.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>selection</em>, <em>negate=False</em>, <em>anomalous_flag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a sub-array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>selection</strong> – flex.bool or flex.size_t selection</li>
<li><strong>negate</strong> – select the inverse of the selection array</li>
<li><strong>anomalous_flag</strong> – anomalous flag for the new set</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new array with a subset of indices and data/sigmas</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.select_indices">
<code class="descname">select_indices</code><span class="sig-paren">(</span><em>indices</em>, <em>map_indices_to_asu=False</em>, <em>negate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.select_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.select_sys_absent">
<code class="descname">select_sys_absent</code><span class="sig-paren">(</span><em>integral_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.select_sys_absent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>crystal_symmetry=Keep</em>, <em>indices=Keep</em>, <em>anomalous_flag=Keep</em>, <em>unit_cell=Keep</em>, <em>space_group_info=Keep</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the basic cctbx.miller.set object for the array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_info">
<code class="descname">set_info</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.set_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_observation_type">
<code class="descname">set_observation_type</code><span class="sig-paren">(</span><em>observation_type</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.set_observation_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_observation_type_xray_amplitude">
<code class="descname">set_observation_type_xray_amplitude</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.set_observation_type_xray_amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag the array as X-ray amplitudes (F).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_observation_type_xray_intensity">
<code class="descname">set_observation_type_xray_intensity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.set_observation_type_xray_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag the array as X-ray intensities (I).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_sigmas">
<code class="descname">set_sigmas</code><span class="sig-paren">(</span><em>sigmas</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.set_sigmas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.shelxl_extinction_correction">
<code class="descname">shelxl_extinction_correction</code><span class="sig-paren">(</span><em>x</em>, <em>wavelength</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.shelxl_extinction_correction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Extinction parameter x, where Fc is multiplied by:</dt>
<dd>k[1 + 0.001 x Fc^2 wavelength^3 / sin(2theta)]^(-1/4)</dd>
</dl>
<p>See SHELX-97 manual, page 7-7 for more information.</p>
<dl class="docutils">
<dt>Note: The scale factor, k, is not applied nor calculated by</dt>
<dd>this function. The scale factor should be calculated
and applied <strong>*AFTER*</strong> the application of the extinction
corrections.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_all_possible_systematic_absences">
<code class="descname">show_all_possible_systematic_absences</code><span class="sig-paren">(</span><em>out=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w'&gt;</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.show_all_possible_systematic_absences" title="Permalink to this definition">¶</a></dt>
<dd><p>For each possible space group sharing the same basic intensity symmetry,
show a list of possible systematically absent reflections and corresponding
I/sigmaI.  Note that if the data have already been processed in a specific
space group rather than the basic point group, for example P212121 instead
of P222, all systematically absent reflections are likely to have been
removed already.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a systematic_absences_info object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_array">
<code class="descname">show_array</code><span class="sig-paren">(</span><em>f=None</em>, <em>prefix=''</em>, <em>deg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.show_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Listing of Miller indices and data</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_comprehensive_summary">
<code class="descname">show_comprehensive_summary</code><span class="sig-paren">(</span><em>f=None</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.show_comprehensive_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Display comprehensive Miller set or array summary</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_disagreeable_reflections">
<code class="descname">show_disagreeable_reflections</code><span class="sig-paren">(</span><em>f_calc_sq</em>, <em>n_reflections=20</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.show_disagreeable_reflections" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_mean_data_over_sigma_along_a_b_c_star">
<code class="descname">show_mean_data_over_sigma_along_a_b_c_star</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.show_mean_data_over_sigma_along_a_b_c_star" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_r_free_flags_info">
<code class="descname">show_r_free_flags_info</code><span class="sig-paren">(</span><em>n_bins=10</em>, <em>binner_range='used'</em>, <em>out=None</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.show_r_free_flags_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_summary">
<code class="descname">show_summary</code><span class="sig-paren">(</span><em>f=None</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.show_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimal Miller set summary</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigma_at_first_index">
<code class="descname">sigma_at_first_index</code><span class="sig-paren">(</span><em>miller_index</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.sigma_at_first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of sigmas of the first index matching
<cite>miller_index</cite>. If the <cite>miller_index</cite> is not found in <cite>self</cite>,
then returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>miller_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a>) – Miller index as a 3-tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">int, float, complex, None – sigmas value or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigma_filter">
<code class="descname">sigma_filter</code><span class="sig-paren">(</span><em>cutoff_factor</em>, <em>negate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.sigma_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array filtered to remove reflections whose value is
less than cutoff_factor*sigma (or the reverse, if negate=True).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigmas">
<code class="descname">sigmas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.sigmas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigmas_are_sensible">
<code class="descname">sigmas_are_sensible</code><span class="sig-paren">(</span><em>critical_ratio=0.75</em>, <em>epsilon=1e-06</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.sigmas_are_sensible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.size">
<code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of reflections in the set or array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sort_permutation">
<code class="descname">sort_permutation</code><span class="sig-paren">(</span><em>by_value='resolution'</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.sort_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the selection array (flex.size_t object) to reorder the array
by resolution, Miller index, data values, or absolute data values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>by_value</strong> – sort type, must be “resolution”, “packed_indices”, “data”,
or “abs”</li>
<li><strong>reverse</strong> – invert order</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">flex.size_t object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.statistical_mean">
<code class="descname">statistical_mean</code><span class="sig-paren">(</span><em>use_binning=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.statistical_mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>use_multiplicities=False</em>, <em>squared=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sum_sq">
<code class="descname">sum_sq</code><span class="sig-paren">(</span><em>use_binning=False</em>, <em>use_multiplicities=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.sum_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.symmetry_agreement_factor">
<code class="descname">symmetry_agreement_factor</code><span class="sig-paren">(</span><em>op</em>, <em>assert_is_similar_symmetry=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.symmetry_agreement_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>The factor phi_{sym} quantifying whether complex structure factors
are invariant under the given symmetry operator, as used in Superflip.
Ref: J. Appl. Cryst. (2008). 41, 975-984</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.translational_shift">
<code class="descname">translational_shift</code><span class="sig-paren">(</span><em>shift_frac</em>, <em>deg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.translational_shift" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Adjust a complex array (map coefficients) or phase array</dt>
<dd>corresponding to a shift of all coordinates by
new_xyz_frac = old_xyz_frac + shift_frac.</dd>
</dl>
<p>If a phase array, must specify whether it is in degrees.
Only makes sense in P1</p>
<p>F’=exp( i 2 pi h.(x+shift_frac)) -&gt; F’ = F exp ( i 2 pi h.shift_frac)
phase_shift = 2 * pi * h . shift_frac</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.twin_data">
<code class="descname">twin_data</code><span class="sig-paren">(</span><em>twin_law</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.twin_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a twin law to the data, returning an array of the same original type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Params twin_law:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">a valid twin law expressed as h,k,l operations</td>
</tr>
<tr class="field-even field"><th class="field-name">Params alpha:</th><td class="field-body">predicted twin fraction (0 to 0.5)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new array with synthetically twinned data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.value_at_index">
<code class="descname">value_at_index</code><span class="sig-paren">(</span><em>hkl</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.value_at_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the value of the array for the specified reflection h,k,l</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.wilson_plot">
<code class="descname">wilson_plot</code><span class="sig-paren">(</span><em>use_binning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.wilson_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;F^2&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.wilson_ratio">
<code class="descname">wilson_ratio</code><span class="sig-paren">(</span><em>use_binning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array.wilson_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>(&lt;F&gt;)^2/&lt;F^2&gt; (0.785 for untwinned, 0.885 for twinned data)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="utility-classes">
<h2>Utility classes<a class="headerlink" href="#utility-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cctbx.miller.merge_equivalents">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">merge_equivalents</code><span class="sig-paren">(</span><em>miller_array</em>, <em>algorithm='gaussian'</em>, <em>incompatible_flags_replacement=None</em>, <em>use_internal_variance=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for merging redundant observations to obtain a symmetry-unique
array.  This also calculates some useful statistics resulting from the
merging operation.  Normally this would not be instantiated directly, but
instead obtained by calling array.merge_equivalents(…).</p>
<dl class="method">
<dt id="cctbx.miller.merge_equivalents.array">
<code class="descname">array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the merged Miller array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_linear">
<code class="descname">r_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>R-linear = sum(abs(data - mean(data))) / sum(abs(data))</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_meas">
<code class="descname">r_meas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_meas" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternate metric of dataset internal consistency.  Explained in detail in
Diederichs K &amp; Karplus PA (1997) Nature Structural Biology 4:269-275.</p>
<div class="math notranslate nohighlight">
\[R_{meas} = \dfrac{\sum_{hkl}{ {\left \{ N(hkl) / [N(hkl) - 1] \right \} }^{1/2} \times \sum_{i}{|I_{i}(hkl) - \left \langle I_{i}(hkl) \right \rangle|}}}{\sum_{hkl}{\sum_{i}{I_{i}(hkl)}}}\]</div>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_merge">
<code class="descname">r_merge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard (but flawed) metric of dataset internal consistency.</p>
<div class="math notranslate nohighlight">
\[R_{merge} = \dfrac{\sum_{hkl}{\sum_{i}{|I_{i}(hkl) - \left \langle I_{i}(hkl) \right \rangle|}}}{\sum_{hkl}{\sum_{i}{I_{i}(hkl)}}}\]</div>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_pim">
<code class="descname">r_pim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_pim" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternate metric of dataset internal consistency or quality.  Explained in
detail in Weiss MS (2001) J Appl Cryst 34:130-135.</p>
<div class="math notranslate nohighlight">
\[R_{meas} = \dfrac{\sum_{hkl}{ {\left \{ 1 / [N(hkl) - 1] \right \} }^{1/2} \times \sum_{i}{|I_{i}(hkl) - \left \langle I_{i}(hkl) \right \rangle|}}}{\sum_{hkl}{\sum_{i}{I_{i}(hkl)}}}\]</div>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_square">
<code class="descname">r_square</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_square" title="Permalink to this definition">¶</a></dt>
<dd><p>R-square = sum((data - mean(data))**2) / sum(data**2)</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.redundancies">
<code class="descname">redundancies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.merge_equivalents.redundancies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array representing the redundancy or multiplicity of each
reflection in the merged array.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cctbx.miller.fft_map">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">fft_map</code><span class="sig-paren">(</span><em>crystal_gridding</em>, <em>fourier_coefficients</em>, <em>f_000=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.fft_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for an FFT from reciprocal space (complex double) into real space.
Normally this is obtained by calling array.fft_map(…), not instantiated
directly outside this module.  If the input array is anomalous, the
resulting map will be a flex.complex_double (with grid accessor), otherwise
it will be a flex.double.</p>
</dd></dl>

<dl class="class">
<dt id="cctbx.miller.array_info">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">array_info</code><span class="sig-paren">(</span><em>source=None</em>, <em>source_type=None</em>, <em>history=None</em>, <em>labels=None</em>, <em>merged=False</em>, <em>systematic_absences_eliminated=False</em>, <em>crystal_symmetry_from_file=None</em>, <em>type_hints_from_file=None</em>, <em>wavelength=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.array_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for metadata associated with a Miller array, including labels
read from a data file.</p>
</dd></dl>

<dl class="class">
<dt id="cctbx.miller.normalised_amplitudes">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">normalised_amplitudes</code><span class="sig-paren">(</span><em>miller_array</em>, <em>asu_contents</em>, <em>wilson_plot=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.normalised_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>E-values and related statistics</p>
</dd></dl>

<dl class="class">
<dt id="cctbx.miller.crystal_symmetry_is_compatible_with_symmetry_from_file">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">crystal_symmetry_is_compatible_with_symmetry_from_file</code><span class="sig-paren">(</span><em>miller_array</em>, <em>unit_cell_relative_length_tolerance=0.02</em>, <em>unit_cell_absolute_angle_tolerance=3.0</em>, <em>working_point_group=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.crystal_symmetry_is_compatible_with_symmetry_from_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="cctbx.miller.binner">
<em class="property">class </em><code class="descclassname">cctbx.miller.</code><code class="descname">binner</code><span class="sig-paren">(</span><em>binning</em>, <em>miller_set</em><span class="sig-paren">)</span><a class="headerlink" href="#cctbx.miller.binner" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="section" id="submodules">
<h3>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cctbx.miller.display.html">cctbx.miller.display module</a></li>
<li class="toctree-l1"><a class="reference internal" href="cctbx.miller.reindexing.html">cctbx.miller.reindexing module</a></li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">cctbx.miller package</a><ul>
<li><a class="reference internal" href="#getting-started">Getting started</a></li>
<li><a class="reference internal" href="#file-i-o">File I/O</a><ul>
<li><a class="reference internal" href="#processing-input-data-practical-aspects">Processing input data - practical aspects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparing-arrays">Comparing arrays</a></li>
<li><a class="reference internal" href="#working-with-experimental-data">Working with experimental data</a></li>
<li><a class="reference internal" href="#from-arrays-to-maps">From arrays to maps</a></li>
<li><a class="reference internal" href="#the-miller-set">The Miller set</a></li>
<li><a class="reference internal" href="#the-miller-array">The Miller array</a></li>
<li><a class="reference internal" href="#utility-classes">Utility classes</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cctbx.merging.brehm_diederichs.html"
                        title="previous chapter">cctbx.merging.brehm_diederichs module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cctbx.miller.display.html"
                        title="next chapter">cctbx.miller.display module</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/cctbx/cctbx.miller.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cctbx.miller.display.html" title="cctbx.miller.display module"
             >next</a> |</li>
        <li class="right" >
          <a href="cctbx.merging.brehm_diederichs.html" title="cctbx.merging.brehm_diederichs module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CCTBX Developer documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="cctbx.html" >cctbx - core crystallographic objects and functions</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, University of California.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>