
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>iotbx.managers &#8212; CCTBX Developer documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="iotbx.file_reader - generic file input" href="iotbx.file_reader.html" />
    <link rel="prev" title="iotbx - file readers and writers" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="iotbx.file_reader.html" title="iotbx.file_reader - generic file input"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="iotbx - file readers and writers"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CCTBX Developer documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">iotbx - file readers and writers</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="iotbx-managers">
<h1><a class="toc-backref" href="#id1">iotbx.managers</a><a class="headerlink" href="#iotbx-managers" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#iotbx-managers" id="id1">iotbx.managers</a><ul>
<li><a class="reference internal" href="#overview" id="id2">Overview</a></li>
<li><a class="reference internal" href="#module-iotbx.map_manager" id="id3">API documentation</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id2">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-iotbx.map_manager">
<span id="api-documentation"></span><h2><a class="toc-backref" href="#id3">API documentation</a><a class="headerlink" href="#module-iotbx.map_manager" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="iotbx.map_manager.add_tuples_int">
<code class="descclassname">iotbx.map_manager.</code><code class="descname">add_tuples_int</code><span class="sig-paren">(</span><em>t1</em>, <em>t2</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.add_tuples_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_manager.get_indices_from_index">
<code class="descclassname">iotbx.map_manager.</code><code class="descname">get_indices_from_index</code><span class="sig-paren">(</span><em>index=None</em>, <em>all=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.get_indices_from_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_manager.get_sites_cart_from_index">
<code class="descclassname">iotbx.map_manager.</code><code class="descname">get_sites_cart_from_index</code><span class="sig-paren">(</span><em>indices_list=None</em>, <em>points=None</em>, <em>map_data=None</em>, <em>crystal_symmetry=None</em>, <em>all=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.get_sites_cart_from_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get sites_cart from linear (1d) map indices.
Supply either map_data or all to provide n_real
crystal_symmetry is required
Supply either 3D indices (i,j,k) or 1-D indices (points)</p>
</dd></dl>

<dl class="class">
<dt id="iotbx.map_manager.map_manager">
<em class="property">class </em><code class="descclassname">iotbx.map_manager.</code><code class="descname">map_manager</code><span class="sig-paren">(</span><em>file_name=None</em>, <em>map_data=None</em>, <em>unit_cell_grid=None</em>, <em>unit_cell_crystal_symmetry=None</em>, <em>origin_shift_grid_units=None</em>, <em>ncs_object=None</em>, <em>wrapping=&lt;libtbx.AutoType object&gt;</em>, <em>experiment_type=&lt;libtbx.AutoType object&gt;</em>, <em>scattering_table=&lt;libtbx.AutoType object&gt;</em>, <em>resolution=&lt;libtbx.AutoType object&gt;</em>, <em>log=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>map_manager, includes map_reader and write_ccp4_map</p>
<p>This class is intended to be the principal mechanism for reading
and writing map information.  It is intended to be used by the
iotbx.data_manager for both of these purposes.</p>
<p>Use map_manager to read, write, and carry information about
one map.  Map_manager keeps track of the origin shifts and also the
original full unit cell and cell dimensions.  It writes out the map
in the same place as it was read in.</p>
<p>Note on wrapping:  Wrapping means that the map value outside the map
boundaries can be obtained as the value inside the boundaries, (translated
by some multiple of the unit cell translations.)  Normally crystallographic
maps can be wrapped and cryo EM maps cannot.</p>
<p>Wrapping should be specified on initialization if not read from a file. If
read from a file, the value from the file labels is used if available,
otherwise it is assumed to be wrapping = False unless specified (normal
for a cryo-EM map. If not specified at all, it will need to be specified
before a map_model_manager is created or the map_manager is written out.</p>
<p>Map_manager also keeps track of any changes in magnification. These
are reflected in changes in unit_cell and crystal_symmetry cell dimensions
and angles.</p>
<p>You normally create a new map_manager by initializing map_manager with a
file name.  Then you apply the shift_origin() method and the map is
shifted to place the origin at (0, 0, 0) and the original origin is
recorded as self.origin_shift_grid_units.</p>
<p>You can also create a map_manager with a map_data object (3D flex.double()
array) along with the meta-data below.</p>
<dl class="docutils">
<dt>NOTE: MRC Maps may not represent the entire unit cell.  Normally maps that</dt>
<dd><p class="first">have an origin (corner with minimum i, j, k) that is not zero will be
shifted at a later stage to have the origin at (0, 0, 0), along with
any models and ncs objects (typically done with iotbx.map_and_model).
To be able to write out a map in the same place as it was read in
after shifting the origin and/or boxing the map, you need to keep track
of 3 things.  These are:
1. unit_cell_grid: grid representing one full unit cell as read in.</p>
<blockquote>
<div>Saved in map_manager as self.unit_cell_grid</div></blockquote>
<ol class="last arabic" start="2">
<li><dl class="first docutils">
<dt>unit_cell_crystal_symmetry: dimensions and space group of full unit cell</dt>
<dd><p class="first last">Saved in map_manager as self._unit_cell_crystal_symmetry</p>
</dd>
</dl>
</li>
<li><p class="first">origin_shift_grid_units: the shift in grid units to apply to the
working map to superimpose it on the original map. When you read the
map in this is (0, 0, 0). If you shift the map origin from (i, j, k) to
(0, 0, 0) then the origin_shift_grid_units is (i, j, k).</p>
<blockquote>
<div><p>Saved in map_manager as self.origin_shift_grid_units</p>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
<p>Magnification (pixel size scaling) of a map: there is no general parameter
describing magnification of an MRC map.  Changes in scaling are
recorded in map_manager as changes in the scaling matrix/translation that
relates grid points in a map to real-space position.</p>
<p>Normal usage (NOTE: read/write should normally be done through data_manager):</p>
<blockquote>
<div><dl class="docutils">
<dt>Read in a map:</dt>
<dd>mm = map_manager(‘input_map.mrc’)</dd>
<dt>Summarize:</dt>
<dd>mm.show_summary()</dd>
<dt>Normally shift origin of map to (0, 0, 0) (you can do this here</dt>
<dd><blockquote class="first">
<div>or you can use iotbx.map_and_model to shift models and maps together):</div></blockquote>
<p class="last">mm.shift_origin()</p>
</dd>
<dt>Get the map_data (shifted if origin was shifted above):</dt>
<dd>map_data = mm.map_data()</dd>
<dt>Get the crystal_symmetry of the box of data that is present:</dt>
<dd>cs = mm.crystal_symmetry()</dd>
<dt>Get the crystal_symmetry of the whole unit cell (even if not present):</dt>
<dd>unit_cell_cs = mm.unit_cell_crystal_symmetry()</dd>
<dt>Write out the map in map_data() in original location:</dt>
<dd>mm.write_map(file_name = ‘output_map.ccp4’)</dd>
</dl>
</div></blockquote>
<p>——–     CONVENTIONS  ————–
See <a class="reference external" href="http://www.ccpem.ac.uk/mrc_format/mrc2014.php">http://www.ccpem.ac.uk/mrc_format/mrc2014.php</a> for MRC format
See <a class="reference external" href="https://pypi.org/project/mrcfile/">https://pypi.org/project/mrcfile/</a> for mrcfile library documentation</p>
<p>Same conventions as iotbx.ccp4_map</p>
<dl class="docutils">
<dt>Default is to write maps with INTERNAL_STANDARD_ORDER of axes of [3, 2, 1]</dt>
<dd>corresponding to columns in Z, rows in Y, sections in X to match
flex array layout.  This can be modified by changing the values in
output_axis_order.</dd>
<dt>Hard-wired to convert input maps of any order to</dt>
<dd><blockquote class="first">
<div>INTERNAL_STANDARD_ORDER = [3, 2, 1] before conversion to flex arrays
This is not modifiable.</div></blockquote>
<p class="last">INTERNAL_STANDARD_ORDER = [3, 2, 1]</p>
</dd>
</dl>
</div></blockquote>
<p>Standard limitations and associated message.
These can be checked with: limitations = mrc.get_limitations()</p>
<blockquote>
<div>which returns a group_args object with a list of limitations and a list
of corresponding error messages, or None if there are none
see phenix.show_map_info for example</div></blockquote>
<dl class="docutils">
<dt>These limitations can also be accessed with specific calls placed below:</dt>
<dd>For example:
mrc.can_be_sharpened()  returns False if “extract_unique” is present</dd>
<dt>Map labels that are not limitations can be accessed with:</dt>
<dd>additional_labels = mrc.get_additional_labels()</dd>
<dt>STANDARD_LIMITATIONS_DICT = {</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>“extract_unique”:</dt>
<dd>“This map is masked around unique region and not suitable for auto-sharpening.”,</dd>
<dt>“map_is_sharpened”:</dt>
<dd>“This map is auto-sharpened and not suitable for further auto-sharpening.”,</dd>
<dt>“map_is_density_modified”: “This map has been density modified.”,</dt>
<dd>}</dd>
</dl>
</div></blockquote>
<p>NOTES ON ORDER OF AXES</p>
<blockquote>
<div><dl class="docutils">
<dt>Phenix standard order is 3, 2, 1 (columns Z, rows Y, sections in X).</dt>
<dd>Convert everything to this order.</dd>
<dt>This is the order that allows direct conversion of a numpy 3D array</dt>
<dd>with axis order (mapc, mapr, maps) to a flex array.</dd>
<dt>For reverse = True, supply order that converts flex array to numpy 3D array</dt>
<dd>with order (mapc, mapr, maps)</dd>
<dt>Note that this does not mean input or output maps have to be in this order.</dt>
<dd><p class="first">It just means that before conversion of numpy to flex or vice-versa
the array has to be in this order.</p>
<p>Note that MRC standard order for input/ouput is 1, 2, 3.</p>
<dl class="last docutils">
<dt>NOTE: numpy arrays indexed from 0 so this is equivalent to</dt>
<dd>order of 2, 1, 0 in the numpy array</dd>
</dl>
</dd>
<dt>NOTE:  MRC format allows data axes to be swapped using the header</dt>
<dd>mapc mapr and maps fields. However the mrcfile library does not
attempt to swap the axes and assigns the columns to X, rows to Y and
sections to Z. The data array is indexed C-style, so data values can
be accessed using mrc.data[z][y][x].</dd>
<dt>NOTE: normal expectation is that phenix will read/write with the</dt>
<dd><p class="first">order 3, 2, 1. This means X-sections (index = 3), Y rows (index = 2),
Z columns (index = 1). This correxponds to</p>
<blockquote class="last">
<div>mapc (columns) =   3 or Z
mapr (rows)    =   2 or Y
maps (sections) =  1 or X</div></blockquote>
</dd>
</dl>
<p>In the numpy array (2, 1, 0 instead of 3, 2, 1):</p>
<dl class="docutils">
<dt>To transpose, specify i0, i1, i2 where:</dt>
<dd><blockquote class="first">
<div>i0 = 2 means input axis 0 becomes output axis 2
NOTE:  axes are 0, 1, 2 etc, not 1, 2, 3</div></blockquote>
<dl class="last docutils">
<dt>Examples:</dt>
<dd>np.transpose(a, (0, 1, 2))  does nothing
np.transpose(a, (1, 2, 0)) output axis 0 is input axis 1</dd>
</dl>
</dd>
<dt>We want output axes to always be 2, 1, 0 and input axes for numpy array are</dt>
<dd>(mapc-1, mapr-1, maps-1):</dd>
<dt>For example, in typical phenix usage, the transposition is:</dt>
<dd>i_mapc = 3    i_mapc_np = 2
i_mapr = 2    i_mapr_np = 1
i_maps = 1    i_maps_np = 0</dd>
</dl>
</div></blockquote>
<p class="last">——–     END CONVENTIONS  ————–</p>
</dd>
</dl>
<dl class="method">
<dt id="iotbx.map_manager.map_manager.absolute_center_cart">
<code class="descname">absolute_center_cart</code><span class="sig-paren">(</span><em>use_assumed_end=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.absolute_center_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return center of map (absolute position) in Cartesian coordinates
A little tricky because for example the map goes from 0 to nx-1, not nx</p>
<blockquote>
<div>If use_assumed_end, go to nx</div></blockquote>
<p>Also map could start at non-zero origin</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.add_label">
<code class="descname">add_label</code><span class="sig-paren">(</span><em>label=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.add_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a label (up to 80-character string) to write to output map.
Default is to specify the program name and date</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.add_limitation">
<code class="descname">add_limitation</code><span class="sig-paren">(</span><em>limitation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.add_limitation" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a limitation from STANDARD_LIMITATIONS_DICT
Supply the key (such as “map_is_sharpened”)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.apply_mask">
<code class="descname">apply_mask</code><span class="sig-paren">(</span><em>set_outside_to_mean_inside=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace map_data with masked version based on current mask
Just uses method in create_mask_around_atoms</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.apply_spectral_scaling">
<code class="descname">apply_spectral_scaling</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>d_max=None</em>, <em>n_bins=100</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.apply_spectral_scaling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.as_full_size_map">
<code class="descname">as_full_size_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.as_full_size_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a full-size map that with the current map inside it, padded by zero</p>
<p>A little tricky because the starting map is going to have its origin at
(0, 0, 0) but the map we are creating will have that point at
self.origin_shift_grid_units.</p>
<dl class="docutils">
<dt>First use box.with_bounds to create map from -self.origin_shift_grid_units</dt>
<dd>to -self.origin_shift_grid_units+self.unit_cell_grid-(1, 1, 1).  Then</dd>
</dl>
<p>shift that map to place origin at (0, 0, 0)</p>
<p>If the map is full size already, return the map as is
If the map is bigger than full size stop as this is not suitable</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.as_map_model_manager">
<code class="descname">as_map_model_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.as_map_model_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a map_model_manager</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.binary_filter">
<code class="descname">binary_filter</code><span class="sig-paren">(</span><em>threshold=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.binary_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a binary filter to the map (value at pixel i,j,k=1 if average
of all 27 pixels within 1 of this one is &gt; threshold, otherwise 0)
Changes and overwrites contents of this map_manager.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.cc_to_other_map_manager">
<code class="descname">cc_to_other_map_manager</code><span class="sig-paren">(</span><em>other_map_manager</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.cc_to_other_map_manager" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.create_mask_around_atoms">
<code class="descname">create_mask_around_atoms</code><span class="sig-paren">(</span><em>model</em>, <em>mask_atoms_atom_radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.create_mask_around_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Use cctbx.maptbx.mask.create_mask_around_atoms to create a mask around
atoms in model</p>
<p>Does not apply the mask (use apply_mask_to_map etc for that)</p>
<p>mask_atoms_atom_radius default is max(3, resolution)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.create_mask_around_density">
<code class="descname">create_mask_around_density</code><span class="sig-paren">(</span><em>resolution=None</em>, <em>molecular_mass=None</em>, <em>sequence=None</em>, <em>solvent_content=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.create_mask_around_density" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Use cctbx.maptbx.mask.create_mask_around_density to create a</dt>
<dd>mask automatically</dd>
</dl>
<p>Does not apply the mask (use apply_mask_to_map etc for that)</p>
<dl class="docutils">
<dt>Parameters are:</dt>
<dd><dl class="first docutils">
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">resolution of map, taken from self.resolution() if not</span></dt>
<dd>specified</dd>
</dl>
<p class="last">molecular_mass: optional mass (Da) of object in density
sequence: optional sequence of object in density
solvent_content : optional solvent_content of map</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.create_mask_around_edges">
<code class="descname">create_mask_around_edges</code><span class="sig-paren">(</span><em>soft_mask_radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.create_mask_around_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Use cctbx.maptbx.mask.create_mask_around_edges to create a mask around
edges of map.  Does not make a soft mask.  For a soft mask,
follow with soft_mask(soft_mask_radius =soft_mask_radius)
The radius is to define the boundary around the map.</p>
<p>Does not apply the mask (use apply_mask_to_map etc for that)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.create_mask_with_map_data">
<code class="descname">create_mask_with_map_data</code><span class="sig-paren">(</span><em>map_data</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.create_mask_with_map_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mask to be map_data</p>
<p>Does not apply the mask (use apply_mask_to_map etc for that)</p>
<p>Uses cctbx.maptbx.mask.create_mask_with_mask_data to do it</p>
<p>Requires origin to be zero of both self and new mask</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.customized_copy">
<code class="descname">customized_copy</code><span class="sig-paren">(</span><em>map_data=None</em>, <em>origin_shift_grid_units=None</em>, <em>use_deep_copy_for_map_data=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.customized_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a customized deep_copy of this map_manager, replacing map_data with
supplied map_data.</p>
<p>The map_data and any _created_mask will be deep_copied before using
them unless use_deep_copy_for_map_data = False</p>
<p>Normally this customized_copy is applied with a map_manager
that has already shifted the origin to (0, 0, 0) with shift_origin.</p>
<p>Normally the new map_data will have the same dimensions of the current
map_data. Normally new map_data will also have origin at (0, 0, 0).</p>
<p>NOTE: It is permissible for map_data to have different bounds or origin
than the current self.map_data.  In this case you must specify a new
value of origin_shift_grid_units corresponding to this new map_data.
This new origin_shift_grid_units specifies the original position in the
full unit cell grid of the most-negative corner grid point of the
new map_data. The new map_manager will still have the same unit
cell dimensions and grid as the original.</p>
<p>NOTE: It is permissible to get a customized copy before shifting the
origin.  Applying with non-zero origin requires that:</p>
<blockquote>
<div><blockquote>
<div><p>self.origin_shift_grid_units == (0, 0, 0)
origin_shift_grid_units = (0, 0, 0)
map_data.all() (size in each direction)  of current and new maps</p>
<blockquote>
<div>are the same.</div></blockquote>
<p>origins of current and new maps are the same</p>
</div></blockquote>
<p>NOTE: wrapping is normally copied from original map, but if new map is
not full size then wrapping is always set to False.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.deep_copy">
<code class="descname">deep_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of this map_manager object
Uses customized_copy to deepcopy everything including map_data</p>
<p>Origin does not have to be at (0, 0, 0) to apply</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.delete_mask">
<code class="descname">delete_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.delete_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.density_at_sites_cart">
<code class="descname">density_at_sites_cart</code><span class="sig-paren">(</span><em>sites_cart</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.density_at_sites_cart" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return flex.double list of density values corresponding to sites (cartesian</dt>
<dd>coordinates in A)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.experiment_type">
<code class="descname">experiment_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.experiment_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.find_map_symmetry">
<code class="descname">find_map_symmetry</code><span class="sig-paren">(</span><em>include_helical_symmetry=False</em>, <em>symmetry_center=None</em>, <em>min_ncs_cc=None</em>, <em>symmetry=None</em>, <em>ncs_object=None</em>, <em>check_crystal_symmetry=True</em>, <em>only_proceed_if_crystal_symmetry=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.find_map_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Use run_get_symmetry_from_map tool in segment_and_split_map to find
map symmetry and save it as an mmtbx.ncs.ncs.ncs object</p>
<p>Here map symmetry is the reconstruction symmetry used to generate the
map. Normally it is essentially perfect symmetry and normally the
principal axes are aligned with x,y,z and normally the center is at
the original center of the map.</p>
<dl class="docutils">
<dt>Sets self._warning_message if failure, sets self._ncs_object and</dt>
<dd>self._ncs_cc if success</dd>
</dl>
<p>This procedure may fail if the above assumptions do not hold.
Optional center of map can be supplied, and minimum NCS correlation
can also be supplied</p>
<p>Requires that map_manager is already shifted to place origin at (0, 0, 0)</p>
<p>Assumes that center of symmetry is at (1/2, 1/2, 1/2) in the full map</p>
<p>It is optional to include search for helical symmetry. Reason is that
this is much slower than other symmetries.</p>
<p>symmetry (symbol such as c1, O, D7) can be supplied and search will be
limited to that symmetry</p>
<p>ncs_object can be supplied in which case it is just checked</p>
<p>If check_crystal_symmetry, try to narrow down possibilities by looking
for space-group symmetry first</p>
<dl class="docutils">
<dt>If only_proceed_if_crystal_symmetry, skip looking if nothing comes up</dt>
<dd>with check_crystal_symmetry</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.find_n_highest_grid_points_as_sites_cart">
<code class="descname">find_n_highest_grid_points_as_sites_cart</code><span class="sig-paren">(</span><em>n=None</em>, <em>n_tolerance=0</em>, <em>max_tries=100</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.find_n_highest_grid_points_as_sites_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the n highest grid points in the map as sites_cart</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.fourier_coefficients_as_map_manager">
<code class="descname">fourier_coefficients_as_map_manager</code><span class="sig-paren">(</span><em>map_coeffs</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.fourier_coefficients_as_map_manager" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Convert Fourier coefficients into to a real-space map with gridding</dt>
<dd>matching this existing map_manager.  Returns a map_manager object.</dd>
</dl>
<p>Requires that this map_manager has origin at (0, 0, 0) (i.e.,
shift_origin() has been applied if necessary)</p>
<p>NOTE: Assumes that the map_coeffs are in the same frame of reference
as this map_manager (i.e., similar to those that would be written out
using map_as_fourier_coefficients).</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.gaussian_filter">
<code class="descname">gaussian_filter</code><span class="sig-paren">(</span><em>smoothing_radius</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.gaussian_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian blur the map in map_manager with given smoothing radius.
Changes and overwrites contents of this map_manager.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.get_boxes_to_tile_map">
<code class="descname">get_boxes_to_tile_map</code><span class="sig-paren">(</span><em>target_for_boxes=24</em>, <em>box_cushion=3</em>, <em>get_unique_set_for_boxes=None</em>, <em>dist_min=None</em>, <em>do_not_go_over_target=None</em>, <em>target_xyz_center_list=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.get_boxes_to_tile_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a group_args object with a list of lower_bounds and upper_bounds
corresponding to a set of boxes that tiles the part of the map that is
present.  The boxes may not be the same size but will tile to exactly
cover the existing part of the map.
Approximately target_for_boxes will be returned (may be fewer or greater)
Also return boxes with cushion of box_cushion
If get_unique_set_for_boxes is set, try to use map symmetry to identify</p>
<blockquote>
<div>duplicates and set ncs_object</div></blockquote>
<dl class="docutils">
<dt>If target_xyz_center_list is set, use these points as centers but try</dt>
<dd>to use standard box size.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.get_density_along_line">
<code class="descname">get_density_along_line</code><span class="sig-paren">(</span><em>start_site=None</em>, <em>end_site=None</em>, <em>n_along_line=10</em>, <em>include_ends=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.get_density_along_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return group_args object with density values and coordinates
along a line segment from start_site to end_site
(cartesian coordinates in A) with n_along_line sampling points.
Optionally include/exclude ends.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.get_mask_as_map_manager">
<code class="descname">get_mask_as_map_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.get_mask_as_map_manager" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.get_n_real_for_grid_spacing">
<code class="descname">get_n_real_for_grid_spacing</code><span class="sig-paren">(</span><em>grid_spacing=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.get_n_real_for_grid_spacing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.grid_units_to_cart">
<code class="descname">grid_units_to_cart</code><span class="sig-paren">(</span><em>grid_units</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.grid_units_to_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert grid units to cartesian coordinates</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.initialize_map_data">
<code class="descname">initialize_map_data</code><span class="sig-paren">(</span><em>map_value=0</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.initialize_map_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all values of map_data to map_value</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.is_compatible_model">
<code class="descname">is_compatible_model</code><span class="sig-paren">(</span><em>model</em>, <em>require_match_unit_cell_crystal_symmetry=True</em>, <em>absolute_angle_tolerance=0.01</em>, <em>absolute_length_tolerance=0.01</em>, <em>shift_tol=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.is_compatible_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Model is compatible with this map_manager if it is not specified as being
different.</p>
<dl class="docutils">
<dt>They are different if:</dt>
<dd><ol class="first arabic simple">
<li>original and current symmetries are present and different from each</li>
</ol>
<blockquote>
<div>other and do not match</div></blockquote>
<ol class="last arabic simple" start="2">
<li>model current symmetry does not match map original or current</li>
<li>model has a shift_cart (shift applied) different than map shift_cart</li>
</ol>
</dd>
</dl>
<p>NOTE: a True result does not mean that the model crystal_symmetry matches
the map crystal_symmetry.  It does mean that it is reasonable to set the
model crystal_symmetry to match the map ones.</p>
<p>If require_match_unit_cell_crystal_symmetry is True, then they are
different if anything is different</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.is_compatible_ncs_object">
<code class="descname">is_compatible_ncs_object</code><span class="sig-paren">(</span><em>ncs_object</em>, <em>tol=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.is_compatible_ncs_object" title="Permalink to this definition">¶</a></dt>
<dd><p>ncs_object is compatible with this map_manager if shift_cart is
the same as map</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.is_consistent_with_wrapping">
<code class="descname">is_consistent_with_wrapping</code><span class="sig-paren">(</span><em>relative_sd_tol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.is_consistent_with_wrapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Report if this map looks like it is a crystallographic map and can be
wrapped</p>
<p>If it is not full size…no wrapping
If origin is not at zero…no wrapping
If it is not periodic, no wrapping
If very small or resolution_factor for map is close to 0.5…cannot tell
If has all zeroes (or some other constant on edges) … no wrapping</p>
<p>relative_sd_tol defines how close to constant values at edges must be
to qualify as “constant”</p>
<p>Returns True, False, or None (unsure)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.is_full_size">
<code class="descname">is_full_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.is_full_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Report if map is full unit cell</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.is_mask">
<code class="descname">is_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.is_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this a mask</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.is_similar">
<code class="descname">is_similar</code><span class="sig-paren">(</span><em>other=None</em>, <em>absolute_angle_tolerance=0.01</em>, <em>absolute_length_tolerance=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.is_similar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.map_as_fourier_coefficients">
<code class="descname">map_as_fourier_coefficients</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>d_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.map_as_fourier_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a map to Fourier coefficients to a resolution of d_min,
if d_min is provided, otherwise box full of map coefficients
will be created.</p>
<p>Filter results with low resolution of d_max if provided</p>
<p>NOTE: Fourier coefficients are relative the working origin (not
original origin).  A map calculated from the Fourier coefficients will
superimpose on the working (current map) without origin shifts.</p>
<p>This method and fourier_coefficients_as_map_manager interconvert
map_data and
map_coefficients without changing origin.  Both are intended for use
with map_data that has an origin at (0, 0, 0).</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.map_map_cc">
<code class="descname">map_map_cc</code><span class="sig-paren">(</span><em>other_map_manager</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.map_map_cc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return simple map correlation to other map_manager</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.minimum_resolution">
<code class="descname">minimum_resolution</code><span class="sig-paren">(</span><em>set_minimum_resolution=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.minimum_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Get minimum resolution.  If set previously, use that value</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.ncs_cc">
<code class="descname">ncs_cc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.ncs_cc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.ncs_object">
<code class="descname">ncs_object</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.ncs_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.origin_is_zero">
<code class="descname">origin_is_zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.origin_is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.randomize">
<code class="descname">randomize</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>low_resolution_fourier_noise_fraction=0.01</em>, <em>high_resolution_fourier_noise_fraction=2</em>, <em>low_resolution_real_space_noise_fraction=0</em>, <em>high_resolution_real_space_noise_fraction=0</em>, <em>low_resolution_noise_cutoff=None</em>, <em>random_seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.randomize" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomize a map.</p>
<p>Unique aspect of this noise generation is that it can be specified
whether the noise is local in real space (every point in a map
gets a random value before Fourier filtering), or local in Fourier
space (every Fourier coefficient gets a complex random offset).
Also the relative contribution of each type of noise vs resolution
can be controlled.</p>
<p>d_min:  high-resolution limit in Fourier transformations</p>
<p>low_resolution_fourier_noise_fraction (float, 0): Low-res Fourier noise
high_resolution_fourier_noise_fraction (float, 0): High-res Fourier noise
low_resolution_real_space_noise_fraction(float, 0): Low-res</p>
<blockquote>
<div>real-space noise</div></blockquote>
<dl class="docutils">
<dt>high_resolution_real_space_noise_fraction (float, 0): High-res</dt>
<dd>real-space noise</dd>
<dt>low_resolution_noise_cutoff (float, None):  Low resolution where noise</dt>
<dd>starts to be added</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.resample_on_different_grid">
<code class="descname">resample_on_different_grid</code><span class="sig-paren">(</span><em>n_real</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.resample_on_different_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the map on a grid of n_real and return new map_manager</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.resolution">
<code class="descname">resolution</code><span class="sig-paren">(</span><em>force=False</em>, <em>method='d99'</em>, <em>set_resolution=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Get nominal resolution
Return existing if present unless force is True
choices:</p>
<blockquote>
<div>d9: resolution correlated at 0.9 with original
d99: resolution correlated at 0.99 with original
d999: resolution correlated at 0.999 with original
d_min: d_min_from_map</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.resolution_filter">
<code class="descname">resolution_filter</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>d_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.resolution_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>High- or low-pass filter the map in map_manager.
Changes and overwrites contents of this map_manager.
Remove all components with resolution &lt; d_min or &gt; d_max
Either d_min or d_max or both can be None.
To make a low_pass filter with cutoff at 3 A, set d_min=3
To make a high_pass filter with cutoff at 2 A, set d_max=2</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.scattering_table">
<code class="descname">scattering_table</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.scattering_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_experiment_type">
<code class="descname">set_experiment_type</code><span class="sig-paren">(</span><em>experiment_type</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_experiment_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the experiment type
xray,neutron, or cryo_em
If scattering_table is not defined, it is guessed from experiment_type</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_is_mask">
<code class="descname">set_is_mask</code><span class="sig-paren">(</span><em>value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_is_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>define if this is a mask</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_log">
<code class="descname">set_log</code><span class="sig-paren">(</span><em>log=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output log file</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_map_data">
<code class="descname">set_map_data</code><span class="sig-paren">(</span><em>map_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_map_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace self.data with map_data. The two maps must have same gridding</p>
<p>NOTE: This uses selections to copy all the data in map_data into
self.data.  The map_data object is not associated with self.data, the
data is simply copied.  Also as self.data is modified in place, any
objects that currently are just pointers to self.data are affected.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_mean_zero_sd_one">
<code class="descname">set_mean_zero_sd_one</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_mean_zero_sd_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to normalize the map</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_model_symmetries_and_shift_cart_to_match_map">
<code class="descname">set_model_symmetries_and_shift_cart_to_match_map</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_model_symmetries_and_shift_cart_to_match_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the model original and working crystal_symmetry to match map.</p>
<p>Overwrites any information in model on symmetry and shift_cart
Modifies model in place</p>
<p>NOTE: This does not shift the coordinates in model.  It is used
to fix crystal symmetry and set shift_cart, not to actually shift
a model.
For shifting a model, use:</p>
<blockquote>
<div>model.shift_model_and_set_crystal_symmetry(shift_cart=shift_cart)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_ncs_object">
<code class="descname">set_ncs_object</code><span class="sig-paren">(</span><em>ncs_object</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_ncs_object" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>set the ncs object for this map_manager.  Incoming ncs_object must</div></blockquote>
<p>be compatible (shift_cart values must match).  Incoming ncs_object is
deep_copied.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_ncs_object_shift_cart_to_match_map">
<code class="descname">set_ncs_object_shift_cart_to_match_map</code><span class="sig-paren">(</span><em>ncs_object</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_ncs_object_shift_cart_to_match_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the ncs_object shift_cart to match map</p>
<p>Overwrites any information in ncs_object on shift_cart
Modifies ncs_object in place</p>
<p>Do not use this to try to shift the ncs object. That is done in
the ncs object itself with ncs_object.coordinate_shift(shift_cart)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_original_origin_and_gridding">
<code class="descname">set_original_origin_and_gridding</code><span class="sig-paren">(</span><em>original_origin=None</em>, <em>gridding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_original_origin_and_gridding" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify the location in the full unit cell grid where the origin of
the map that is present is to be placed to match its original position.
This is referred to here as the “original” origin, as opposed to the
current origin of this map.</p>
<p>Note that this method does not actually shift the origin of the working
map.  It just defines where that origin is going to be placed when
restoring the map to its original position.</p>
<p>Also optionally redefine the definition of the unit cell, keeping the
grid spacing the same.</p>
<p>This allows redefining the location of the map that is present
within the full unit cell.  It also allows redefining the
unit cell itself.  Only use this to create a new partial map
in a defined location.</p>
<p>Previous definition of the location of the map that is present
is discarded.</p>
<dl class="docutils">
<dt>Fundamental parameters set:</dt>
<dd>self.origin_shift_grid_units: shift to place origin in original location
self._unit_cell_crystal_symmetry: dimensions of full unit cell
self.unit_cell_grid: grid units of full unit cell</dd>
</dl>
<p>At end, recheck wrapping</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_program_name">
<code class="descname">set_program_name</code><span class="sig-paren">(</span><em>program_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_program_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set name of program doing work on this map_manager for output
(string)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_resolution">
<code class="descname">set_resolution</code><span class="sig-paren">(</span><em>resolution</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the nominal resolution of map</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_scattering_table">
<code class="descname">set_scattering_table</code><span class="sig-paren">(</span><em>scattering_table</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_scattering_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the scattering table (type of scattering)
electron:  cryo_em
n_gaussian x-ray (standard)
wk1995:    x-ray (alternative)
it1992:    x-ray (alternative)
neutron:   neutron scattering</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_unit_cell_crystal_symmetry">
<code class="descname">set_unit_cell_crystal_symmetry</code><span class="sig-paren">(</span><em>crystal_symmetry</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_unit_cell_crystal_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify the dimensions and space group of unit cell.  This also changes
the crystal_symmetry of the part that is present and the grid spacing.</p>
<p>Purpose is to redefine the dimensions of the map without changing values
of the map.  Normally used to correct the dimensions of a map
where something was defined incorrectly.</p>
<p>Does not change self.unit_cell_grid</p>
<blockquote>
<div><dl class="docutils">
<dt>Fundamental parameters set:</dt>
<dd>self._unit_cell_crystal_symmetry: dimensions of full unit cell
self._crystal_symmetry: dimensions of part of unit cell that is present</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.set_wrapping">
<code class="descname">set_wrapping</code><span class="sig-paren">(</span><em>wrapping_value</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.set_wrapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Set wrapping to be wrapping_value</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.shift_aware_rt">
<code class="descname">shift_aware_rt</code><span class="sig-paren">(</span><em>from_obj=None</em>, <em>to_obj=None</em>, <em>working_rt_info=None</em>, <em>absolute_rt_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.shift_aware_rt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns shift_aware_rt object</p>
<p>Uses rt_info objects (group_args with members of r, t).</p>
<dl class="docutils">
<dt>Simplifies keeping track of rotation/translation between two</dt>
<dd>objects that each may have an offset from absolute coordinates.</dd>
<dt>absolute rt is rotation/translation when everything is in original,</dt>
<dd>absolute cartesian coordinates.</dd>
<dt>working_rt is rotation/translation of anything in “from_obj” object</dt>
<dd>to anything in “to_obj” object using working coordinates in each.</dd>
</dl>
<p>Usage:
shift_aware_rt = self.shift_aware_rt(absolute_rt_info = rt_info)
shift_aware_rt = self.shift_aware_rt(working_rt_info = rt_info,</p>
<blockquote>
<div>from_obj=from_obj, to_obj = to_obj)</div></blockquote>
<p>apply RT using working coordinates in objects
sites_cart_to_obj = shift_aware_rt.apply_rt(sites_cart_from_obj,</p>
<blockquote>
<div>from_obj=from_obj, to_obj=to_obj)</div></blockquote>
<p>apply RT absolute coordinates
sites_cart_to = shift_aware_rt.apply_rt(sites_cart_from)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.shift_cart">
<code class="descname">shift_cart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.shift_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the shift_cart of this map from its original location.</p>
<p>(the negative of the origin shift ) in cartesian coordinates</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.shift_model_to_match_map">
<code class="descname">shift_model_to_match_map</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.shift_model_to_match_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the model to match this map
Note difference from set_model_symmetries_and_shift_cart_to_match_map</p>
<blockquote>
<div>which sets model symmetry and shift_cart but does not move the model</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.shift_ncs_object_to_match_map">
<code class="descname">shift_ncs_object_to_match_map</code><span class="sig-paren">(</span><em>ncs_object</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.shift_ncs_object_to_match_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the ncs_object to match this map</p>
<dl class="docutils">
<dt>Note difference from set_ncs_object_shift_cart_to_match_map which</dt>
<dd>sets the shift_cart but does not move the object</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.shift_origin">
<code class="descname">shift_origin</code><span class="sig-paren">(</span><em>desired_origin=(0</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.shift_origin" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Shift the origin of the map to desired_origin</dt>
<dd>(normally desired_origin = (0, 0, 0) and update origin_shift_grid_units</dd>
</dl>
<p>Origin is the value of self.map_data().origin()
origin_shift_grid_units is the shift to apply to self.map_data() to</p>
<blockquote>
<div>superimpose it on the original map.</div></blockquote>
<dl class="docutils">
<dt>If you shift the origin by (i, j, k) then add -(i, j, k) to</dt>
<dd>the current origin_shift_grid_units.</dd>
<dt>If current origin is at (a, b, c) and</dt>
<dd>desired origin = (d, e, f) and
existing origin_shift_grid_units is (g, h, i):</dd>
</dl>
<p>the shift to make is  (d, e, f) - (a, b, c)</p>
<dl class="docutils">
<dt>the new value of origin_shift_grid_units will be:</dt>
<dd>(g, h, i)+(a, b, c)-(d, e, f)
or new origin_shift_grid_units is: (g, h, i)- shift</dd>
</dl>
<p>the new origin of map_data will be (d, e, f)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.shift_origin_to_match_original">
<code class="descname">shift_origin_to_match_original</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.shift_origin_to_match_original" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift origin by self.origin_shift_grid_units to place origin in its
original location</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.soft_mask">
<code class="descname">soft_mask</code><span class="sig-paren">(</span><em>soft_mask_radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.soft_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Make mask a soft mask. Just uses method in cctbx.maptbx.mask
Use resolution for soft_mask radius if not specified</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.trace_atoms_in_map">
<code class="descname">trace_atoms_in_map</code><span class="sig-paren">(</span><em>dist_min</em>, <em>n_atoms</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.trace_atoms_in_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility to find positions where n_atoms atoms separated by
dist_min can be placed in density in this map</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.warning_message">
<code class="descname">warning_message</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.warning_message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.wrapping">
<code class="descname">wrapping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.wrapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Report if map can be wrapped</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.map_manager.write_map">
<code class="descname">write_map</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.map_manager.write_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple version of write</p>
<p>file_name is output file name
map_data is map_data object with 3D values for map. If not supplied,</p>
<blockquote>
<div>use self.map_data()</div></blockquote>
<p>Normally call with file_name (file to be written)
Output labels are generated from existing self.labels,
self.program_name, and self.limitations</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="iotbx.map_manager.remove_site_with_most_neighbors">
<code class="descclassname">iotbx.map_manager.</code><code class="descname">remove_site_with_most_neighbors</code><span class="sig-paren">(</span><em>sites_cart</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.remove_site_with_most_neighbors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_manager.select_n_in_biggest_cluster">
<code class="descclassname">iotbx.map_manager.</code><code class="descname">select_n_in_biggest_cluster</code><span class="sig-paren">(</span><em>sites_cart</em>, <em>dist_min=None</em>, <em>n=None</em>, <em>dist_min_ratio=1.0</em>, <em>dist_min_ratio_min=0.5</em>, <em>minimize_density_of_points=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.select_n_in_biggest_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Select n of sites_cart, taking those near biggest cluster if possible
If minimize_density_of_points, remove those with the most neighbors</p>
</dd></dl>

<dl class="class">
<dt id="iotbx.map_manager.shift_aware_rt">
<em class="property">class </em><code class="descclassname">iotbx.map_manager.</code><code class="descname">shift_aware_rt</code><span class="sig-paren">(</span><em>from_obj=None</em>, <em>to_obj=None</em>, <em>working_rt_info=None</em>, <em>absolute_rt_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.shift_aware_rt" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to simplify keeping track of rotation/translation between two
objects that each may have an offset from absolute coordinates.</p>
<p>Basic idea:  absolute rt is rotation/translation when everything is in
original, absolute cartesian coordinates.</p>
<dl class="docutils">
<dt>working_rt is rotation/translation of anything in “from_obj” object to anything</dt>
<dd>in “to_obj” object using working coordinates in each.</dd>
</dl>
<p>The from_obj and to objects must have a shift_cart method</p>
<dl class="method">
<dt id="iotbx.map_manager.shift_aware_rt.absolute_rt_info">
<code class="descname">absolute_rt_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.shift_aware_rt.absolute_rt_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.shift_aware_rt.apply_rt">
<code class="descname">apply_rt</code><span class="sig-paren">(</span><em>site_cart=None</em>, <em>sites_cart=None</em>, <em>from_obj=None</em>, <em>to_obj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.shift_aware_rt.apply_rt" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply absolute rt if from and to not specified.
Apply relative if specified</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.shift_aware_rt.get_absolute_rt_info">
<code class="descname">get_absolute_rt_info</code><span class="sig-paren">(</span><em>working_rt_info=None</em>, <em>from_obj=None</em>, <em>to_obj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.shift_aware_rt.get_absolute_rt_info" title="Permalink to this definition">¶</a></dt>
<dd><p>working_rt_info describes how to map from_xyz -&gt; to_xyz in local coordinates
from_xyz is shifted from absolute by from.shift_cart()
to_xyz is shifted from absolute by to.shift_cart()</p>
<dl class="docutils">
<dt>We have:</dt>
<dd>r from_xyz + t = to_xyz    in working frame of reference</dd>
<dt>We want to describe how to map:</dt>
<dd>(from_xyz - from.shift_cart()) -&gt; (to_xyz - to.shift_cart())</dd>
<dt>where r is going to be the same and T will be different than t</dt>
<dd><p class="first">r ((from_xyz - from.shift_cart()) + T = (to_xyz - to.shift_cart())
T = (to_xyz - to.shift_cart() - r from_xyz + r from.shift_cart()</p>
<blockquote>
<div>but: to_xyz -  r from_xyz = t</div></blockquote>
<p class="last">T =  t - to.shift_cart() + r from.shift_cart()</p>
</dd>
<dt>Note reverse:</dt>
<dd>t = T + to.shift_cart() - r from.shift_cart()</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.shift_aware_rt.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.shift_aware_rt.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.shift_aware_rt.is_similar">
<code class="descname">is_similar</code><span class="sig-paren">(</span><em>other_shift_aware_rt_info</em>, <em>tol=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.shift_aware_rt.is_similar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_manager.shift_aware_rt.working_rt_info">
<code class="descname">working_rt_info</code><span class="sig-paren">(</span><em>from_obj=None</em>, <em>to_obj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.shift_aware_rt.working_rt_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rt in working frame of reference</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="iotbx.map_manager.subtract_tuples_int">
<code class="descclassname">iotbx.map_manager.</code><code class="descname">subtract_tuples_int</code><span class="sig-paren">(</span><em>t1</em>, <em>t2</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_manager.subtract_tuples_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-iotbx.map_model_manager"></span><dl class="function">
<dt id="iotbx.map_model_manager.apply_ncs_to_dv_results">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">apply_ncs_to_dv_results</code><span class="sig-paren">(</span><em>direction_vectors=None</em>, <em>xyz=None</em>, <em>scaling_group_info=None</em>, <em>ncs_object=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.apply_ncs_to_dv_results" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.create_fine_spacing_array">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">create_fine_spacing_array</code><span class="sig-paren">(</span><em>unit_cell</em>, <em>cell_ratio=10</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.create_fine_spacing_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.create_map_manager_with_value_list">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">create_map_manager_with_value_list</code><span class="sig-paren">(</span><em>n_real=None</em>, <em>crystal_symmetry=None</em>, <em>value_list=None</em>, <em>sites_cart_list=None</em>, <em>target_spacing=None</em>, <em>max_iterations=None</em>, <em>default_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.create_map_manager_with_value_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a map_manager with values set with a set of sites_cart and values
Use nearest available value for each grid point, done iteratively</p>
<blockquote>
<div>with radii in shells of target_spacing/2 and up to max_iterations shells</div></blockquote>
<p>If default_value is set, use that for all empty locations after
max_iterations</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.cutoff_values">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">cutoff_values</code><span class="sig-paren">(</span><em>inside=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.cutoff_values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_average_scale_factors">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_average_scale_factors</code><span class="sig-paren">(</span><em>scale_factor_info</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_average_scale_factors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_center_of_box_frac">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_center_of_box_frac</code><span class="sig-paren">(</span><em>lower_bounds=None</em>, <em>upper_bounds=None</em>, <em>n_real=None</em>, <em>crystal_symmetry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_center_of_box_frac" title="Permalink to this definition">¶</a></dt>
<dd><p>get center of this box</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_map_coeffs_as_fp_phi">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_map_coeffs_as_fp_phi</code><span class="sig-paren">(</span><em>map_coeffs</em>, <em>d_min=None</em>, <em>n_bins=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_map_coeffs_as_fp_phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Get map_coeffs as fp and phi. also set up binner if n_bins is not None</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_map_counts">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_map_counts</code><span class="sig-paren">(</span><em>map_data</em>, <em>crystal_symmetry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_map_counts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_map_histograms">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_map_histograms</code><span class="sig-paren">(</span><em>data</em>, <em>n_slots=20</em>, <em>data_1=None</em>, <em>data_2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_map_histograms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_normalization_data_for_unit_binning">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_normalization_data_for_unit_binning</code><span class="sig-paren">(</span><em>f_array</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_normalization_data_for_unit_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Get normalizations for each reflection in a scheme for
interpolating a top-hat function over bins</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_pointer_to_old_dv_id_dict">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_pointer_to_old_dv_id_dict</code><span class="sig-paren">(</span><em>working_dv_list=None</em>, <em>dv_list=None</em>, <em>very_similar=0.95</em>, <em>allow_multiple_use=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_pointer_to_old_dv_id_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>For each member of working_dv_list, identify best match to member of
dv_list. Only use each dv_list member once unless allow_multiple_use.
ID by abs(dot product)
allow_multiple_use is for matching any to dv_list, False is for
#  rearranging only</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_selection_inside_box">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_selection_inside_box</code><span class="sig-paren">(</span><em>lower_bounds=None</em>, <em>upper_bounds=None</em>, <em>n_real=None</em>, <em>model=None</em>, <em>crystal_symmetry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_selection_inside_box" title="Permalink to this definition">¶</a></dt>
<dd><p>get selection for all the atoms inside this box</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_selections_and_boxes_to_split_model">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_selections_and_boxes_to_split_model</code><span class="sig-paren">(</span><em>map_model_manager=None</em>, <em>selection_method='by_chain'</em>, <em>selection_list=None</em>, <em>skip_waters=False</em>, <em>skip_hetero=False</em>, <em>target_for_boxes=24</em>, <em>box_cushion=3</em>, <em>select_final_boxes_based_on_model=None</em>, <em>skip_empty_boxes=True</em>, <em>mask_around_unselected_atoms=None</em>, <em>mask_all_maps_around_edges=None</em>, <em>mask_radius=3</em>, <em>masked_value=-10</em>, <em>get_unique_set_for_boxes=True</em>, <em>mask_id=None</em>, <em>exclude_points_outside_density=None</em>, <em>minimum_boxes_inside_density=25</em>, <em>log=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_selections_and_boxes_to_split_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Split up model into pieces using selection_method
Choices are [‘by_chain’, ‘by_segment’,’all’, ‘boxes’]
by_chain:  each chain is a selection
by_segment:  each unbroken part of a chain is a selection
boxes:  map is split into target_for_boxes boxes, all atoms in</p>
<blockquote>
<div>each box selected requires map_model_manager to be present</div></blockquote>
<p>Skip waters or hetero atoms in selections if specified
If select_final_boxes_based_on_model and selection_method == ‘boxes’ then</p>
<blockquote>
<div>make the final boxes just go around the selected parts of the model and
not tile the map.</div></blockquote>
<p>If skip_empty_boxes then skip anything with no model.
if get_unique_set_for_boxes then get a unique set for ‘boxes’ method
If mask_id is set and exclude_points_outside_density , skip boxes</p>
<blockquote>
<div><blockquote>
<div>outside of mask for boxes method</div></blockquote>
<dl class="docutils">
<dt>If exclude_points_outside_density,</dt>
<dd>try to add boxes inside density (basically add the proportional
number of boxes but put them definitely inside the density instead
of evenly spaced.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_selections_for_segments">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_selections_for_segments</code><span class="sig-paren">(</span><em>model</em>, <em>no_water_or_het_with_and=''</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_selections_for_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate selections corresponding to each segment (chain or part of a chain
that is separate from remainder of chain)</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_selections_from_boxes">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_selections_from_boxes</code><span class="sig-paren">(</span><em>box_info=None</em>, <em>model=None</em>, <em>overall_selection=None</em>, <em>skip_empty_boxes=None</em>, <em>mask_map_manager=None</em>, <em>exclude_points_outside_density=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_selections_from_boxes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Generate a list of selections that covers all the atoms in model,</dt>
<dd>grouped by the boxes defined in box_info</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_skip_waters_and_hetero_lines">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_skip_waters_and_hetero_lines</code><span class="sig-paren">(</span><em>skip_waters</em>, <em>skip_hetero</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_skip_waters_and_hetero_lines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_split_maps_and_models">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_split_maps_and_models</code><span class="sig-paren">(</span><em>map_model_manager=None</em>, <em>box_info=None</em>, <em>first_to_use=None</em>, <em>last_to_use=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_split_maps_and_models" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply selections and boxing in box_info to generate a set of
small map_model_managers</p>
<dl class="docutils">
<dt>if mask_around_unselected_atoms is set, then mask within each box</dt>
<dd><p class="first">around all the atoms that are not selected (including waters/hetero)
with a mask_radius of mask_radius and set the value inside the mask to</p>
<blockquote class="last">
<div><p>masked_value</p>
<blockquote>
<div>mask_around_unselected_atoms = mask_around_unselected_atoms,
mask_radius = mask_radius,
masked_value = masked_value,</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_tlso_group_info_from_model">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_tlso_group_info_from_model</code><span class="sig-paren">(</span><em>model</em>, <em>nproc=1</em>, <em>log=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_tlso_group_info_from_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract tlso_group_info from aniso records in model</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_tlso_resid">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_tlso_resid</code><span class="sig-paren">(</span><em>T</em>, <em>L</em>, <em>S</em>, <em>cm</em>, <em>u_cart</em>, <em>xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_tlso_resid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.get_weights_for_unit_binning">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">get_weights_for_unit_binning</code><span class="sig-paren">(</span><em>f_array</em>, <em>i_bin</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.get_weights_for_unit_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>get weighting for each reflection in a scheme for
interpolating a top-hat function over bins</p>
</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.is_inside_mask">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">is_inside_mask</code><span class="sig-paren">(</span><em>mask_map_manager</em>, <em>site_frac=None</em>, <em>inside=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.is_inside_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="iotbx.map_model_manager.map_model_manager">
<em class="property">class </em><code class="descclassname">iotbx.map_model_manager.</code><code class="descname">map_model_manager</code><span class="sig-paren">(</span><em>model=None</em>, <em>map_manager=None</em>, <em>map_manager_1=None</em>, <em>map_manager_2=None</em>, <em>extra_model_list=None</em>, <em>extra_model_id_list=None</em>, <em>extra_map_manager_list=None</em>, <em>extra_map_manager_id_list=None</em>, <em>ncs_object=None</em>, <em>ignore_symmetry_conflicts=None</em>, <em>wrapping=None</em>, <em>absolute_angle_tolerance=0.01</em>, <em>absolute_length_tolerance=0.01</em>, <em>log=None</em>, <em>make_cell_slightly_different_in_abc=False</em>, <em>name='map_model_manager'</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for shifting origin of map(s) and model to (0, 0, 0) and keeping
track of the shifts.</p>
<p>Typical use:
mam = map_model_manager(</p>
<blockquote>
<div>model = model,
map_manager = map_manager,
ncs_object = ncs_object)</div></blockquote>
<dl class="docutils">
<dt>mam.box_all_maps_around_model_and_shift_origin(</dt>
<dd>box_cushion=3)</dd>
</dl>
<p>shifted_model = mam.model()  # at (0, 0, 0), knows about shifts
shifted_map_manager = mam.map_manager() # also at (0, 0, 0) knows shifts
shifted_ncs_object = mam.ncs_object() # also at (0, 0, 0) and knows shifts</p>
<p>Optional after boxing:  apply soft mask to map (requires soft_mask_radius)</p>
<dl class="docutils">
<dt>The maps allowed are:</dt>
<dd><dl class="first docutils">
<dt>map_dict has four special ids with interpretations:</dt>
<dd>map_manager:  full map
map_manager_1, map_manager_2: half-maps 1 and 2
map_manager_mask:  a mask as a map_manager</dd>
</dl>
<p class="last">All other ids are any strings and are assumed to correspond to other maps</p>
</dd>
<dt>Note:  It is permissible to call with no map_manger, but supplying</dt>
<dd>both map_manager_1 and map_manager_2.  In this case, the working
map_manager will be the average of map_manager_1 and map_manager_2. This
will be created the first time map_manager is referenced.</dd>
</dl>
<p>Note:  mam.map_manager() contains mam.ncs_object(), so it is not necessary
to keep both.</p>
<p>Note: model objects may contain internal ncs objects.  These are separate
from those in the map_managers and separate from ncs_object in the call to
map_model_manager.</p>
<p>The ncs_object describes the NCS of the map and is a property of the map. It
must be shared by all maps</p>
<p>The model ncs objects describe the NCS of the individual model. They can
differ between models and between models and maps.</p>
<p>Note: set wrapping of all maps to match map_manager if they differ. Set
all to be wrapping if it is set</p>
<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.add_map_from_fourier_coefficients">
<code class="descname">add_map_from_fourier_coefficients</code><span class="sig-paren">(</span><em>map_coeffs</em>, <em>map_id='map_from_fourier_coefficients'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.add_map_from_fourier_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Create map_manager from map_coeffs and add it to maps with map_id
The map_coeffs must refer to a map with origin at (0, 0, 0) such as
is produced by map_as_fourier_coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.add_map_manager_by_id">
<code class="descname">add_map_manager_by_id</code><span class="sig-paren">(</span><em>map_manager</em>, <em>map_id</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.add_map_manager_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new map_manager
Must be similar to existing
Overwrites any existing with the same id unless overwrite = False
Is a mask if is_mask is set</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.add_model_by_id">
<code class="descname">add_model_by_id</code><span class="sig-paren">(</span><em>model</em>, <em>model_id</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.add_model_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new model
Must be similar to existing map_managers
Overwrites any existing with the same id unless overwrite = False</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.apply_mask_to_map">
<code class="descname">apply_mask_to_map</code><span class="sig-paren">(</span><em>map_id</em>, <em>mask_id='mask'</em>, <em>set_outside_to_mean_inside=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.apply_mask_to_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the mask in ‘mask’ to map specified by map_id</p>
<dl class="docutils">
<dt>Optionally set the value outside the mask equal to the mean inside,</dt>
<dd>changing smoothly from actual values inside the mask to the constant
value outside (otherwise outside everything is set to zero)</dd>
</dl>
<p>Optionally use any mask specified by mask_id</p>
<p>NOTE: Does not change the gridding or shift_cart of the map</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.apply_mask_to_maps">
<code class="descname">apply_mask_to_maps</code><span class="sig-paren">(</span><em>map_ids=None</em>, <em>mask_id='mask'</em>, <em>set_outside_to_mean_inside=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.apply_mask_to_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the mask in ‘mask’ to maps specified by map_ids.
If map_ids is None apply to all</p>
<dl class="docutils">
<dt>Optionally set the value outside the mask equal to the mean inside,</dt>
<dd>changing smoothly from actual values inside the mask to the constant
value outside (otherwise outside everything is set to zero)</dd>
</dl>
<p>Optionally use any mask specified by mask_id</p>
<p>NOTE: Does not change the gridding or shift_cart of the maps</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.as_map_model_manager">
<code class="descname">as_map_model_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.as_map_model_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this object (allows using .as_map_model_manager() on both
map_model_manager objects and others including box.around_model() etc.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.as_match_map_model_ncs">
<code class="descname">as_match_map_model_ncs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.as_match_map_model_ncs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this object as a match_map_model_ncs</p>
<p>Includes only the map_manager and model and ncs object, ignores all
other maps and models (match_map_model_ncs takes only one of each).</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.box_all_maps_around_density_and_shift_origin">
<code class="descname">box_all_maps_around_density_and_shift_origin</code><span class="sig-paren">(</span><em>box_cushion=5.0</em>, <em>threshold=0.05</em>, <em>map_id='map_manager'</em>, <em>get_half_height_width=True</em>, <em>model_can_be_outside_bounds=None</em>, <em>extract_box=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.box_all_maps_around_density_and_shift_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Box all maps around the density in map_id map (default is map_manager)
shift origin of maps, model</p>
<p>If extract_box=True:  Creates new object with deep_copies.
Otherwise: replaces existing map_managers and shifts model in place</p>
<p>Replaces existing map_managers and shifts model in place</p>
<p>NOTE: This changes the gridding and shift_cart of the maps and model</p>
<p>Can be used in map_model_manager to work with boxed maps
and model or in map_model_manager to re-box all maps and model</p>
<p>Does not require a model, but a model can be supplied.  If model is
supplied, it is possible that the model will be outside the density
after boxing.
To avoid this, use box_all_maps_around_model_and_shift_origin instead.</p>
<p>The box_cushion defines how far away from the nearest density the new
box boundaries will be placed</p>
<p>The threshold defines how much (relative to maximum in map)  above
mean value of map near edges is significant and should count as density.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.box_all_maps_around_mask_and_shift_origin">
<code class="descname">box_all_maps_around_mask_and_shift_origin</code><span class="sig-paren">(</span><em>box_cushion=5.0</em>, <em>mask_id='mask'</em>, <em>model_can_be_outside_bounds=None</em>, <em>extract_box=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.box_all_maps_around_mask_and_shift_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Box all maps around specified mask, shift origin of maps, model
Replaces existing map_managers and shifts model in place</p>
<p>If extract_box=True:  Creates new object with deep_copies.
Otherwise: replaces existing map_managers and shifts model in place</p>
<p>NOTE: This changes the gridding and shift_cart of the maps and model</p>
<p>Requires a mask</p>
<p>The box_cushion defines how far away from the edge of the mask the new
box boundaries will be placed</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.box_all_maps_around_model_and_shift_origin">
<code class="descname">box_all_maps_around_model_and_shift_origin</code><span class="sig-paren">(</span><em>selection_string=None</em>, <em>selection=None</em>, <em>box_cushion=5.0</em>, <em>select_unique_by_ncs=False</em>, <em>model_can_be_outside_bounds=None</em>, <em>extract_box=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.box_all_maps_around_model_and_shift_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Box all maps around the model, shift origin of maps, model
If extract_box=True:  Creates new object with deep_copies.
Otherwise: replaces existing map_managers and shifts model in place</p>
<p>NOTE: This changes the gridding and shift_cart of the maps and model</p>
<p>Can be used in map_model_manager to work with boxed maps
and model or in map_model_manager to re-box all maps and model</p>
<p>Requires a model</p>
<p>The box_cushion defines how far away from the nearest atoms the new
box boundaries will be placed</p>
<dl class="docutils">
<dt>The selection_string defines what part of the model to keep (‘ALL’ is</dt>
<dd>default)</dd>
</dl>
<p>If selection is specified, use instead of selection_string</p>
<p>If select_unique_by_ncs is set, select the unique part of the model
automatically.  Any selection in selection_string or selection</p>
<blockquote>
<div>will not be applied.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.box_all_maps_around_unique_and_shift_origin">
<code class="descname">box_all_maps_around_unique_and_shift_origin</code><span class="sig-paren">(</span><em>resolution=None</em>, <em>solvent_content=None</em>, <em>sequence=None</em>, <em>molecular_mass=None</em>, <em>soft_mask=True</em>, <em>chain_type='PROTEIN'</em>, <em>box_cushion=5</em>, <em>target_ncs_au_model=None</em>, <em>regions_to_keep=None</em>, <em>keep_low_density=True</em>, <em>symmetry=None</em>, <em>mask_expand_ratio=1</em>, <em>extract_box=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.box_all_maps_around_unique_and_shift_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Box all maps using bounds obtained with around_unique,
shift origin of maps, model, and mask around unique region</p>
<p>If extract_box=True:  Creates new object with deep_copies.
Otherwise: replaces existing map_managers and shifts model in place</p>
<p>Replaces existing map_managers and shifts model in place</p>
<p>NOTE: This changes the gridding and shift_cart of the maps and model
and masks the map</p>
<p>Normally supply just sequence; resolution will be taken from
map_manager resolution if present.  other options match
all possible ways that segment_and_split_map can estimate solvent_content</p>
<p>Must supply one of (sequence, solvent_content, molecular_mass)</p>
<p>Symmetry is optional symmetry (i.e., D7 or C1). Used as alternative to
ncs_object supplied in map_manager</p>
<dl class="docutils">
<dt>Additional parameters:</dt>
<dd><dl class="first docutils">
<dt>mask_expand_ratio:   allows increasing masking radius beyond default at</dt>
<dd>final stage of masking</dd>
</dl>
<p>solvent_content:  fraction of cell not occupied by macromolecule
sequence:        one-letter code of sequence of unique part of molecule
chain_type:       PROTEIN or RNA or DNA. Used with sequence to estimate</p>
<blockquote>
<div>molecular_mass</div></blockquote>
<dl class="docutils">
<dt>molecular_mass:    Molecular mass (Da) of entire molecule used to</dt>
<dd>estimate solvent_content</dd>
<dt>target_ncs_au_model: model marking center of location to choose as</dt>
<dd>unique</dd>
</dl>
<p>box_cushion:        buffer around unique region to be boxed
soft_mask:  use soft mask
keep_low_density:  keep low density regions
regions_to_keep:   Allows choosing just highest-density contiguous</p>
<blockquote class="last">
<div>region (regions_to_keep=1) or a few</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.box_all_maps_with_bounds_and_shift_origin">
<code class="descname">box_all_maps_with_bounds_and_shift_origin</code><span class="sig-paren">(</span><em>lower_bounds</em>, <em>upper_bounds</em>, <em>model_can_be_outside_bounds=None</em>, <em>extract_box=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.box_all_maps_with_bounds_and_shift_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Box all maps using specified bounds, shift origin of maps, model
Replaces existing map_managers and shifts model in place</p>
<p>If extract_box=True:  Creates new object with deep_copies.
Otherwise: replaces existing map_managers and shifts model in place</p>
<p>NOTE: This changes the gridding and shift_cart of the maps and model</p>
<p>Can be used in map_model_manager to work with boxed maps
and model or in map_model_manager to re-box all maps and model</p>
<p>The lower_bounds and upper_bounds define the region to be boxed. These
bounds are relative to the current map with origin at (0, 0, 0).</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.counts">
<code class="descname">counts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.counts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.create_mask_around_atoms">
<code class="descname">create_mask_around_atoms</code><span class="sig-paren">(</span><em>model=None</em>, <em>mask_atoms_atom_radius=3</em>, <em>soft_mask=False</em>, <em>soft_mask_radius=None</em>, <em>mask_id='mask'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.create_mask_around_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate mask based on model.  Does not apply the mask to anything.
Normally follow with apply_mask_to_map or apply_mask_to_maps</p>
<p>Optional: radius around atoms for masking
Optional: soft mask  (default = True)</p>
<blockquote>
<div><p>Radius will be soft_mask_radius
(default radius is self.resolution() or resolution calculated</p>
<blockquote>
<div>from gridding)</div></blockquote>
<dl class="docutils">
<dt>If soft mask is set, mask_atoms_atom_radius increased by</dt>
<dd>soft_mask_radius</dd>
</dl>
</div></blockquote>
<p>Generates new entry in map_manager dictionary with id of
mask_id (default=’mask’) replacing any existing entry with that id</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.create_mask_around_density">
<code class="descname">create_mask_around_density</code><span class="sig-paren">(</span><em>resolution=None</em>, <em>solvent_content=None</em>, <em>soft_mask=True</em>, <em>soft_mask_radius=None</em>, <em>mask_id='mask'</em>, <em>map_id='map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.create_mask_around_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate mask based on density in map_manager (map_id defines it).
Does not apply the mask to anything.
Normally follow with apply_mask_to_map or apply_mask_to_maps</p>
<p>Optional:  supply working resolution
Optional:  supply approximate solvent fraction</p>
<dl class="docutils">
<dt>Optional: soft mask  (default = True)</dt>
<dd>Radius will be soft_mask_radius
(default radius is resolution calculated from gridding)</dd>
</dl>
<p>Generates new entry in map_manager dictionary with id of
mask_id (default=’mask’) replacing any existing entry with that id</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.create_mask_around_edges">
<code class="descname">create_mask_around_edges</code><span class="sig-paren">(</span><em>soft_mask_radius=None</em>, <em>mask_id='mask'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.create_mask_around_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate new mask map_manager with soft mask around edges of mask
Does not apply the mask to anything.
Normally follow with apply_mask_to_map or apply_mask_to_maps</p>
<dl class="docutils">
<dt>Optional: radius around edge for masking</dt>
<dd><dl class="first last docutils">
<dt>(default radius is self.resolution() or resolution calculated</dt>
<dd>from gridding)</dd>
</dl>
</dd>
</dl>
<p>Generates new entry in map_manager dictionary with id of
mask_id (default=’mask’) replacing any existing entry with that id</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.create_masked_copies_of_maps">
<code class="descname">create_masked_copies_of_maps</code><span class="sig-paren">(</span><em>map_id_list=None</em>, <em>mask_id='mask'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.create_masked_copies_of_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Create masked copies of all maps identified by map_id_list (default is all)
Return list of map_id for masked versions</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.crystal_symmetry">
<code class="descname">crystal_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.crystal_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the working crystal_symmetry</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.customized_copy">
<code class="descname">customized_copy</code><span class="sig-paren">(</span><em>model_dict=None</em>, <em>map_dict=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.customized_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a copy of this map_model object, replacing nothing,
maps or models, or both</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.deep_copy">
<code class="descname">deep_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep_copy of this map_manager
Use customized copy with default map_dict and model_dict (from self)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.duplicate_map_manager">
<code class="descname">duplicate_map_manager</code><span class="sig-paren">(</span><em>map_id='map_manager'</em>, <em>new_map_id='new_map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.duplicate_map_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate (deep_copy) map_manager
Overwrites any existing with the new id</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.expand_mask">
<code class="descname">expand_mask</code><span class="sig-paren">(</span><em>buffer_radius=5</em>, <em>resolution=None</em>, <em>soft_mask=True</em>, <em>soft_mask_radius=None</em>, <em>mask_id='mask'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.expand_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.experiment_type">
<code class="descname">experiment_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.experiment_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.external_sharpen">
<code class="descname">external_sharpen</code><span class="sig-paren">(</span><em>map_id='map_manager'</em>, <em>map_id_external_map='external_map'</em>, <em>map_id_to_be_scaled_list=None</em>, <em>map_id_scaled_list=None</em>, <em>exclude_points_outside_density=None</em>, <em>resolution=None</em>, <em>d_min=None</em>, <em>k_sol=None</em>, <em>b_sol=None</em>, <em>n_bins=None</em>, <em>n_boxes=None</em>, <em>core_box_size=None</em>, <em>box_cushion=None</em>, <em>smoothing_radius=None</em>, <em>local_sharpen=None</em>, <em>anisotropic_sharpen=None</em>, <em>expected_ssqr_list=None</em>, <em>expected_ssqr_list_rms=None</em>, <em>tlso_group_info=None</em>, <em>overall_sharpen_before_and_after_local=False</em>, <em>get_scale_as_aniso_u=None</em>, <em>use_dv_weighting=None</em>, <em>n_direction_vectors=None</em>, <em>run_analyze_anisotropy=True</em>, <em>nproc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.external_sharpen" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Scale map_id with scale factors identified from map_id vs</dt>
<dd>map_id_external_map</dd>
</dl>
<p>Changes the working map_manager</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.extract_all_maps_around_density">
<code class="descname">extract_all_maps_around_density</code><span class="sig-paren">(</span><em>box_cushion=5.0</em>, <em>threshold=0.05</em>, <em>get_half_height_width=True</em>, <em>model_can_be_outside_bounds=None</em>, <em>map_id='map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.extract_all_maps_around_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs box_all_maps_around_density_and_shift_origin with extract_box=True</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.extract_all_maps_around_mask">
<code class="descname">extract_all_maps_around_mask</code><span class="sig-paren">(</span><em>box_cushion=5.0</em>, <em>model_can_be_outside_bounds=None</em>, <em>mask_id='mask'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.extract_all_maps_around_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs box_all_maps_around_mask_and_shift_origin with extract_box=True</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.extract_all_maps_around_model">
<code class="descname">extract_all_maps_around_model</code><span class="sig-paren">(</span><em>selection_string=None</em>, <em>selection=None</em>, <em>select_unique_by_ncs=False</em>, <em>model_can_be_outside_bounds=None</em>, <em>box_cushion=5.0</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.extract_all_maps_around_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs box_all_maps_around_model_and_shift_origin with extract_box=True
Use either selection_string or selection if present</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.extract_all_maps_around_unique">
<code class="descname">extract_all_maps_around_unique</code><span class="sig-paren">(</span><em>resolution=None</em>, <em>solvent_content=None</em>, <em>sequence=None</em>, <em>molecular_mass=None</em>, <em>soft_mask=True</em>, <em>chain_type='PROTEIN'</em>, <em>box_cushion=5</em>, <em>target_ncs_au_model=None</em>, <em>regions_to_keep=None</em>, <em>keep_low_density=True</em>, <em>symmetry=None</em>, <em>mask_expand_ratio=1</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.extract_all_maps_around_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs box_all_maps_around_mask_and_shift_origin with extract_box=True</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.extract_all_maps_with_bounds">
<code class="descname">extract_all_maps_with_bounds</code><span class="sig-paren">(</span><em>lower_bounds</em>, <em>upper_bounds</em>, <em>model_can_be_outside_bounds=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.extract_all_maps_with_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs box_all_maps_with_bounds_and_shift_origin with extract_box=True</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.find_k_sol_b_sol">
<code class="descname">find_k_sol_b_sol</code><span class="sig-paren">(</span><em>model=None</em>, <em>d_min=None</em>, <em>model_map_id=None</em>, <em>comparison_map_id=None</em>, <em>n_bins=5</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.find_k_sol_b_sol" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to guess k_sol and b_sol by low-resolution Fc calculation</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.generate_map">
<code class="descname">generate_map</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>origin_shift_grid_units=None</em>, <em>file_name=None</em>, <em>model=None</em>, <em>n_residues=None</em>, <em>b_iso=30</em>, <em>k_sol=None</em>, <em>b_sol=None</em>, <em>box_cushion=5</em>, <em>scattering_table=None</em>, <em>fractional_error=0.0</em>, <em>gridding=None</em>, <em>wrapping=False</em>, <em>map_id=None</em>, <em>f_obs_array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.generate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple interface to cctbx.development.generate_map allowing only
a small subset of keywords. Useful for quick generation of models, map
coefficients, and maps</p>
<p>For full functionality use cctbx.development.generate_model,
cctbx.development.generate_map_coeffs, and
cctbx.development.generate_map</p>
<dl class="docutils">
<dt>If no map_manager is present, use supplied or existing model to</dt>
<dd>generate map_manager and model.</dd>
<dt>If map_manager is present, use supplied or existing model as model and</dt>
<dd>create new entry in this this map_model_manager with name map_id.
If map_id is None, use ‘model_map’</dd>
</dl>
<p>If no existing or supplied model, use default model from library,
box with box_cushion around it and choose n_residues to
include (default=10).</p>
<p>model (model.manager object, None):    model to use (as is)
file_name (path , None):    file containing coordinates to use (instead</p>
<blockquote>
<div>of default model)</div></blockquote>
<dl class="docutils">
<dt>n_residues (int, 10):      Number of residues to include (from default</dt>
<dd>model or file_name)</dd>
</dl>
<p>b_iso (float, 30):         B-value (ADP) to use for all atoms
box_cushion (float, 5):     Buffer (A) around model
d_min (float, 3):      high_resolution limit (A)
gridding (tuple (nx, ny, nz), None):  Gridding of map (optional)
origin_shift_grid_units (tuple (ix, iy, iz), None):  Move location of</p>
<blockquote>
<div>origin of resulting map to (ix, iy, iz) before writing out</div></blockquote>
<p>wrapping:  Defines if map is to be specified as wrapped
scattering_table (choice, ‘electron’): choice of scattering table</p>
<blockquote>
<div>All choices: wk1995 it1992 n_gaussian neutron electron</div></blockquote>
<dl class="docutils">
<dt>fractional_error:  resolution-dependent fractional error, ranging from</dt>
<dd>zero at low resolution to fractional_error at d_min. Can
be more than 1.</dd>
<dt>map_id:  ID of map_manager to be created with model-map information (only</dt>
<dd>applies if there is an existing map_manager)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_any_map_manager">
<code class="descname">get_any_map_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_any_map_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Return any map manager</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_counts_and_histograms">
<code class="descname">get_counts_and_histograms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_counts_and_histograms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_map_data_by_id">
<code class="descname">get_map_data_by_id</code><span class="sig-paren">(</span><em>map_id</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_map_data_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get map_data from a map_manager with the name map_id</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_map_manager_by_id">
<code class="descname">get_map_manager_by_id</code><span class="sig-paren">(</span><em>map_id</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_map_manager_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a map_manager with the name map_id
If map_id is ‘map_manager’ specifically return self.map_manager()
so that it will create a map_manager from map_manager_1 and map_manager_2
if map_manager is not present</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_model_by_id">
<code class="descname">get_model_by_id</code><span class="sig-paren">(</span><em>model_id</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_model_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a model with the name model_id</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_model_from_other">
<code class="descname">get_model_from_other</code><span class="sig-paren">(</span><em>other</em>, <em>other_model_id='model'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_model_from_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a model with id other_model_id from other_map_model_manager with any
boxing and origin shifts allowed, and put it in the same reference
frame as the current model.  Used to build up a model from pieces
that were worked on in separate boxes.</p>
<p>Changes model from other in place</p>
<p>Parameters:  other:  Other map_model_manager containing a model</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_ncs_from_map">
<code class="descname">get_ncs_from_map</code><span class="sig-paren">(</span><em>use_existing=True</em>, <em>include_helical_symmetry=False</em>, <em>symmetry_center=None</em>, <em>min_ncs_cc=None</em>, <em>symmetry=None</em>, <em>ncs_object=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_ncs_from_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Use existing ncs object in map if present or find ncs from map
Sets ncs_object in self.map_manager()
Sets self._ncs_cc which can be retrieved with self.ncs_cc()</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_ncs_from_model">
<code class="descname">get_ncs_from_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_ncs_from_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return model NCS as ncs_spec object if available
Does not set anything. If you want to save it use:</p>
<blockquote>
<div>self.set_ncs_object(self.get_ncs_from_model())
This will set the ncs object in the map_manager (if present)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.get_rms_f_list">
<code class="descname">get_rms_f_list</code><span class="sig-paren">(</span><em>map_id='map_manager'</em>, <em>d_min=None</em>, <em>n_bins=None</em>, <em>resolution=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.get_rms_f_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of rms amplitude by bins</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.half_map_sharpen">
<code class="descname">half_map_sharpen</code><span class="sig-paren">(</span><em>map_id='map_manager'</em>, <em>map_id_1='map_manager_1'</em>, <em>map_id_2='map_manager_2'</em>, <em>map_id_scaled_list=None</em>, <em>map_id_to_be_scaled_list=None</em>, <em>exclude_points_outside_density=None</em>, <em>resolution=None</em>, <em>d_min=None</em>, <em>k_sol=None</em>, <em>b_sol=None</em>, <em>n_bins=None</em>, <em>n_boxes=None</em>, <em>core_box_size=None</em>, <em>box_cushion=None</em>, <em>smoothing_radius=None</em>, <em>rmsd=None</em>, <em>local_sharpen=None</em>, <em>anisotropic_sharpen=None</em>, <em>minimum_low_res_cc=None</em>, <em>get_scale_as_aniso_u=None</em>, <em>use_dv_weighting=None</em>, <em>n_direction_vectors=None</em>, <em>run_analyze_anisotropy=True</em>, <em>spectral_scaling=True</em>, <em>expected_rms_fc_list=None</em>, <em>expected_ssqr_list=None</em>, <em>expected_ssqr_list_rms=None</em>, <em>tlso_group_info=None</em>, <em>model_id_for_rms_fc=None</em>, <em>replace_aniso_with_tls_equiv=None</em>, <em>max_abs_b=None</em>, <em>nproc=None</em>, <em>optimize_b_eff=None</em>, <em>equalize_power=None</em>, <em>overall_sharpen_before_and_after_local=False</em>, <em>get_tls_info_only=None</em>, <em>coordinate_shift_to_apply_before_tlso=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.half_map_sharpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale map_id with scale factors identified from map_id_1 vs map_id_2
Changes the working map_manager unless map_id_scaled_list is set.</p>
<dl class="docutils">
<dt>max_abs_b applies if get_scale_as_aniso_u and anisotropic_sharpen and</dt>
<dd>local_sharpen are set. It limits range of anisotropic B.  Default is
100 at 4 A, proportional to resolution squared</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.hierarchy">
<code class="descname">hierarchy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.hierarchy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.histograms">
<code class="descname">histograms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.histograms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.initialize_maps">
<code class="descname">initialize_maps</code><span class="sig-paren">(</span><em>map_value=0</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.initialize_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Set values of all maps to map_value
Used to set up an empty set of maps for filling in from boxes</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.local_fsc">
<code class="descname">local_fsc</code><span class="sig-paren">(</span><em>map_id='map_manager'</em>, <em>map_id_1='map_manager_1'</em>, <em>map_id_2='map_manager_2'</em>, <em>map_id_to_be_scaled_list=None</em>, <em>map_id_scaled_list=None</em>, <em>mask_id=None</em>, <em>exclude_points_outside_density=None</em>, <em>resolution=None</em>, <em>d_min=None</em>, <em>k_sol=None</em>, <em>b_sol=None</em>, <em>max_resolution_ratio=None</em>, <em>min_bin_width=20</em>, <em>n_bins=None</em>, <em>fsc_cutoff=0.143</em>, <em>n_boxes=None</em>, <em>core_box_size=None</em>, <em>box_cushion=None</em>, <em>rmsd=None</em>, <em>smoothing_radius=None</em>, <em>nproc=None</em>, <em>is_model_based=None</em>, <em>optimize_b_eff=None</em>, <em>equalize_power=None</em>, <em>is_external_based=None</em>, <em>return_scale_factors=False</em>, <em>direction_vectors=None</em>, <em>minimum_low_res_cc=None</em>, <em>get_scale_as_aniso_u=None</em>, <em>use_dv_weighting=None</em>, <em>n_direction_vectors=None</em>, <em>run_analyze_anisotropy=None</em>, <em>spectral_scaling=None</em>, <em>expected_rms_fc_list=None</em>, <em>expected_ssqr_list=None</em>, <em>expected_ssqr_list_rms=None</em>, <em>tlso_group_info=None</em>, <em>model_id_for_rms_fc=None</em>, <em>replace_aniso_with_tls_equiv=None</em>, <em>max_abs_b=None</em>, <em>get_tls_info_only=None</em>, <em>coordinate_shift_to_apply_before_tlso=None</em>, <em>n_bins_default=2000</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.local_fsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates local Fourier Shell Correlations to estimate local resolution
Creates map with smoothed local resolution</p>
<p>Optionally estimates scale factors vs resolution at each point in map
to apply to yield a locally-scaled map (return_scale_factors = True).</p>
<p>If direction_vector is specified, weight scale factor calculation by
dot product of reflection directions with direction_vector</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_as_fourier_coefficients">
<code class="descname">map_as_fourier_coefficients</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>d_max=None</em>, <em>map_id='map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_as_fourier_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Miller array to resolution specified based on map with id map_id</p>
<p>Note that the map_manager is always zero-based (origin at (0,0,0)).
The Fourier coefficients represent the map in this location at (0, 0, 0)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_data">
<code class="descname">map_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_data_1">
<code class="descname">map_data_1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_data_1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_data_2">
<code class="descname">map_data_2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_data_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_data_list">
<code class="descname">map_data_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_data_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_dict">
<code class="descname">map_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dictionary of all maps and masks as map_manager objects</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_id_list">
<code class="descname">map_id_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_id_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the names (ids) for all map_managers that are present</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_manager">
<code class="descname">map_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the map_manager</p>
<p>If not present, calculate it from map_manager_1 and map_manager_2
and set it.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_manager_1">
<code class="descname">map_manager_1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_manager_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Get half_map 1 as a map_manager object</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_manager_2">
<code class="descname">map_manager_2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_manager_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Get half_map 2 as a map_manager object</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_manager_mask">
<code class="descname">map_manager_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_manager_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mask as a map_manager object</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_managers">
<code class="descname">map_managers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_managers" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the map_managers as a list</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_map_cc">
<code class="descname">map_map_cc</code><span class="sig-paren">(</span><em>map_id='map_manager_1'</em>, <em>other_map_id='map_manager_2'</em>, <em>mask_id=None</em>, <em>mask_cutoff=0.5</em>, <em>resolution=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_map_cc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_map_fsc">
<code class="descname">map_map_fsc</code><span class="sig-paren">(</span><em>map_id_1='map_manager_1'</em>, <em>map_id_2='map_manager_2'</em>, <em>resolution=None</em>, <em>mask_id=None</em>, <em>mask_cutoff=0.5</em>, <em>min_bin_width=20</em>, <em>n_bins=2000</em>, <em>fsc_cutoff=0.143</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_map_fsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the map-map FSC for these two maps, optionally masked with mask_id
Returns fsc object which contains d_min which is d_min where fsc</p>
<blockquote>
<div>drops to fsc_cutoff, and sub-object fsc with arrays d, d_inv and
fsc which are the FSC curve</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.map_model_cc">
<code class="descname">map_model_cc</code><span class="sig-paren">(</span><em>resolution=None</em>, <em>map_id='map_manager'</em>, <em>model_id='model'</em>, <em>selection_string=None</em>, <em>model=None</em>, <em>use_b_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.map_model_cc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.mask_all_maps_around_atoms">
<code class="descname">mask_all_maps_around_atoms</code><span class="sig-paren">(</span><em>mask_atoms_atom_radius=3</em>, <em>set_outside_to_mean_inside=False</em>, <em>soft_mask=False</em>, <em>soft_mask_radius=None</em>, <em>mask_id='mask'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.mask_all_maps_around_atoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.mask_all_maps_around_density">
<code class="descname">mask_all_maps_around_density</code><span class="sig-paren">(</span><em>solvent_content=None</em>, <em>soft_mask=True</em>, <em>soft_mask_radius=None</em>, <em>mask_id='mask'</em>, <em>map_id='map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.mask_all_maps_around_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a soft mask around density.  Mask calculated using map_id and
written to mask_id . Overwrites values in maps
Default is to use ‘mask’ as the mask id</p>
<p>NOTE: Does not change the gridding or shift_cart of the maps and model</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.mask_all_maps_around_edges">
<code class="descname">mask_all_maps_around_edges</code><span class="sig-paren">(</span><em>soft_mask_radius=None</em>, <em>mask_id='mask'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.mask_all_maps_around_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a soft mask around edges of all maps. Overwrites values in maps
Use ‘mask’ as the mask id</p>
<p>NOTE: Does not change the gridding or shift_cart of the maps and model</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.merge_split_maps_and_models">
<code class="descname">merge_split_maps_and_models</code><span class="sig-paren">(</span><em>box_info=None</em>, <em>replace_coordinates=True</em>, <em>replace_u_aniso=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.merge_split_maps_and_models" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Replaces coordinates in working model with those from the</dt>
<dd>map_model_managers in box_info.  The box_info object should
come from running split_up_map_and_model in this instance
of the map_model_manager.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.minimum_resolution">
<code class="descname">minimum_resolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.minimum_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return d_min, normally minimum available but if set, return
value of d_min</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.model">
<code class="descname">model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the model</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.model_building">
<code class="descname">model_building</code><span class="sig-paren">(</span><em>nproc=1</em>, <em>soft_zero_boundary_mask=True</em>, <em>soft_zero_boundary_mask_radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.model_building" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this object as a local_model_building object
The model-building object has pointers to model and map_manager, not</p>
<blockquote>
<div><blockquote>
<div>copies</div></blockquote>
<p>resolution is resolution for Fourier coefficients
is_xray_map is True for x-ray map
nproc is number of processors to use</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.model_dict">
<code class="descname">model_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.model_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dictionary of all models</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.model_id_list">
<code class="descname">model_id_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.model_id_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the names (ids) for all models</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.model_sharpen">
<code class="descname">model_sharpen</code><span class="sig-paren">(</span><em>map_id='map_manager'</em>, <em>model_id='model'</em>, <em>map_id_scaled_list=None</em>, <em>map_id_to_be_scaled_list=None</em>, <em>exclude_points_outside_density=True</em>, <em>resolution=None</em>, <em>d_min=None</em>, <em>k_sol=None</em>, <em>b_sol=None</em>, <em>find_k_sol_b_sol=True</em>, <em>d_min_for_k_sol_b_sol=6.0</em>, <em>n_bins=None</em>, <em>n_boxes=None</em>, <em>core_box_size=None</em>, <em>box_cushion=None</em>, <em>smoothing_radius=None</em>, <em>rmsd=None</em>, <em>local_sharpen=None</em>, <em>anisotropic_sharpen=None</em>, <em>minimum_low_res_cc=None</em>, <em>get_scale_as_aniso_u=None</em>, <em>use_dv_weighting=None</em>, <em>n_direction_vectors=None</em>, <em>run_analyze_anisotropy=True</em>, <em>spectral_scaling=True</em>, <em>expected_rms_fc_list=None</em>, <em>expected_ssqr_list=None</em>, <em>expected_ssqr_list_rms=None</em>, <em>tlso_group_info=None</em>, <em>find_tls_from_model=None</em>, <em>model_id_for_rms_fc=None</em>, <em>replace_aniso_with_tls_equiv=None</em>, <em>max_abs_b=None</em>, <em>nproc=None</em>, <em>optimize_b_eff=None</em>, <em>equalize_power=None</em>, <em>map_id_model_map='model_map_for_scaling'</em>, <em>optimize_with_model=None</em>, <em>overall_sharpen_before_and_after_local=False</em>, <em>mask_around_model=True</em>, <em>get_tls_info_only=None</em>, <em>coordinate_shift_to_apply_before_tlso=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.model_sharpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale map_id with scale factors identified from map_id vs model
Changes the working map_manager unless map_id_scaled is set.</p>
<dl class="docutils">
<dt>max_abs_b applies if get_scale_as_aniso_u and anisotropic_sharpen and</dt>
<dd>local_sharpen are set. It limits range of anisotropic B.  Default is
100 at 4 A, proportional to resolution squared</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.models">
<code class="descname">models</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.models" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the models as a list</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.ncs_cc">
<code class="descname">ncs_cc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.ncs_cc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.ncs_object">
<code class="descname">ncs_object</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.ncs_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.propagate_model_from_other">
<code class="descname">propagate_model_from_other</code><span class="sig-paren">(</span><em>other</em>, <em>model_id='model'</em>, <em>other_model_id='model'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.propagate_model_from_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Import a model from other with get_model_from_other (other_model_id),
then set coordinates of corresponding atoms in model_id</p>
<p>The model in other must have been extracted from the model in this object
or one just like it with select_unique_by_ncs=True, and no atoms can
have been added or removed.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.remove_anisotropy">
<code class="descname">remove_anisotropy</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>map_coeffs=None</em>, <em>u_cart_to_remove=None</em>, <em>u_cart_to_add=None</em>, <em>overall_u_cart_to_apply=None</em>, <em>overall_u_cart_to_remove=None</em>, <em>overall_scale=None</em>, <em>map_id='map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.remove_anisotropy" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Remove anisotropy from map, optionally remove anisotropy specified by</dt>
<dd>overall_u_cart_to_remove</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.remove_map_manager_by_id">
<code class="descname">remove_map_manager_by_id</code><span class="sig-paren">(</span><em>map_id='extra'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.remove_map_manager_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this map manager
Note: you cannot remove ‘map_manager’ … you can only replace it</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.remove_model_by_id">
<code class="descname">remove_model_by_id</code><span class="sig-paren">(</span><em>model_id='extra'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.remove_model_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this model</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.remove_model_outside_map">
<code class="descname">remove_model_outside_map</code><span class="sig-paren">(</span><em>model=None</em>, <em>boundary=3</em>, <em>return_as_new_model=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.remove_model_outside_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all the atoms in the model that are well outside the map (more
than boundary)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.resolution">
<code class="descname">resolution</code><span class="sig-paren">(</span><em>use_fsc_if_no_resolution_available_and_maps_available=True</em>, <em>map_id_1='map_manager_1'</em>, <em>map_id_2='map_manager_2'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.resolution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.resolution_filter">
<code class="descname">resolution_filter</code><span class="sig-paren">(</span><em>d_min=None</em>, <em>d_max=None</em>, <em>map_id='map_manager'</em>, <em>new_map_id='map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.resolution_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolution-filter a map with range of d_min to d_max and place in
new map (can be the same)</p>
<p>Typically used along with duplicate_map_manager to create a new map and
filter it:</p>
<blockquote>
<div><dl class="docutils">
<dt>rm.duplicate_map_manager(map_id=’map_manager’,</dt>
<dd>new_map_id=’resolution_filtered’)</dd>
</dl>
<p>rm.resolution_filter(map_id = ‘resolution_filtered’,)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.scattering_table">
<code class="descname">scattering_table</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.scattering_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_experiment_type">
<code class="descname">set_experiment_type</code><span class="sig-paren">(</span><em>experiment_type</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_experiment_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Set nominal experiment_type</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_log">
<code class="descname">set_log</code><span class="sig-paren">(</span><em>log=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output log file</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_map_id_lists">
<code class="descname">set_map_id_lists</code><span class="sig-paren">(</span><em>kw</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_map_id_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_map_manager">
<code class="descname">set_map_manager</code><span class="sig-paren">(</span><em>map_manager</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_map_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites existing map_manager with id ‘map_manager’</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_minimum_resolution">
<code class="descname">set_minimum_resolution</code><span class="sig-paren">(</span><em>d_min</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_minimum_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Set minimum resolution used in calculations</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_model">
<code class="descname">set_model</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites existing model with id ‘model’</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_multiprocessing">
<code class="descname">set_multiprocessing</code><span class="sig-paren">(</span><em>nproc=None</em>, <em>multiprocessing=None</em>, <em>queue_run_command=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_multiprocessing" title="Permalink to this definition">¶</a></dt>
<dd><p>Set multiprocessing parameters</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_name">
<code class="descname">set_name</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set name</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_ncs_object">
<code class="descname">set_ncs_object</code><span class="sig-paren">(</span><em>ncs_object</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_ncs_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the ncs object of map_manager</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_original_origin_grid_units">
<code class="descname">set_original_origin_grid_units</code><span class="sig-paren">(</span><em>original_origin_grid_units=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_original_origin_grid_units" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Reset (redefine) the original origin of the maps and models (apply an</dt>
<dd>origin shift in effect).</dd>
<dt>Procedure is: calculate shift_cart and set origin_shift_grid_units and</dt>
<dd>shift_cart everywhere</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_resolution">
<code class="descname">set_resolution</code><span class="sig-paren">(</span><em>resolution</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Set nominal resolution</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_scattering_table">
<code class="descname">set_scattering_table</code><span class="sig-paren">(</span><em>scattering_table</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_scattering_table" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Set nominal scattering_table. Overrides anything in map_managers</dt>
<dd>electron:  cryo_em
n_gaussian x-ray (standard)
wk1995:    x-ray (alternative)
it1992:    x-ray (alternative)
neutron:   neutron scattering</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_up_map_dict">
<code class="descname">set_up_map_dict</code><span class="sig-paren">(</span><em>map_manager=None</em>, <em>map_manager_1=None</em>, <em>map_manager_2=None</em>, <em>extra_map_manager_list=None</em>, <em>extra_map_manager_id_list=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_up_map_dict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>map_dict has four special ids with interpretations:</dt>
<dd>map_manager:  full map
map_manager_1, map_manager_2: half-maps 1 and 2
map_manager_mask:  a mask in a map_manager</dd>
</dl>
<p>All other ids are any strings and are assumed to correspond to other maps
map_manager must be present</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_up_model_dict">
<code class="descname">set_up_model_dict</code><span class="sig-paren">(</span><em>model=None</em>, <em>extra_model_list=None</em>, <em>extra_model_id_list=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_up_model_dict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>map_dict has one special id with interpretation:</dt>
<dd>model:  standard model</dd>
</dl>
<p>All other ids are any strings and are assumed to correspond to other
models.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.set_verbose">
<code class="descname">set_verbose</code><span class="sig-paren">(</span><em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.set_verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>Set verbose</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.shift_any_model_to_match">
<code class="descname">shift_any_model_to_match</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.shift_any_model_to_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Take any model and shift it to match the working shift_cart
Also sets crystal_symmetry.
Changes model in place</p>
<blockquote>
<div>Parameters:  model</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.shift_aware_rt">
<code class="descname">shift_aware_rt</code><span class="sig-paren">(</span><em>from_obj=None</em>, <em>to_obj=None</em>, <em>working_rt_info=None</em>, <em>absolute_rt_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.shift_aware_rt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns shift_aware_rt object</p>
<p>Uses rt_info objects (group_args with members of r, t).</p>
<dl class="docutils">
<dt>Simplifies keeping track of rotation/translation between two</dt>
<dd>objects that each may have an offset from absolute coordinates.</dd>
<dt>absolute rt is rotation/translation when everything is in original,</dt>
<dd>absolute cartesian coordinates.</dd>
<dt>working_rt is rotation/translation of anything in “from_obj” object</dt>
<dd>to anything in “to_obj” object using working coordinates in each.</dd>
</dl>
<p>Usage:
shift_aware_rt = self.shift_aware_rt(absolute_rt_info = rt_info)
shift_aware_rt = self.shift_aware_rt(working_rt_info = rt_info,</p>
<blockquote>
<div>from_obj=from_obj, to_obj = to_obj)</div></blockquote>
<p>apply RT using working coordinates in objects
sites_cart_to_obj = shift_aware_rt.apply_rt(sites_cart_from_obj,</p>
<blockquote>
<div>from_obj=from_obj, to_obj=to_obj)</div></blockquote>
<p>apply RT absolute coordinates
sites_cart_to = shift_aware_rt.apply_rt(sites_cart_from)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.shift_aware_rt_to_superpose_other">
<code class="descname">shift_aware_rt_to_superpose_other</code><span class="sig-paren">(</span><em>other</em>, <em>selection_string=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.shift_aware_rt_to_superpose_other" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Identify rotation/translation to map model from other on to model in this</dt>
<dd>object.</dd>
<dt>Optionally apply selection_string to both models before doing the</dt>
<dd>mapping</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.shift_cart">
<code class="descname">shift_cart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.shift_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>get the shift_cart (shift since original location)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.shift_origin_to_match_original">
<code class="descname">shift_origin_to_match_original</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.shift_origin_to_match_original" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the origin of all maps and models to match original</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.show_summary">
<code class="descname">show_summary</code><span class="sig-paren">(</span><em>log=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.show_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_boxes">
<code class="descname">split_up_map_and_model_by_boxes</code><span class="sig-paren">(</span><em>skip_waters=False</em>, <em>skip_hetero=False</em>, <em>write_files=False</em>, <em>target_for_boxes=24</em>, <em>select_final_boxes_based_on_model=True</em>, <em>box_cushion=3</em>, <em>mask_around_unselected_atoms=None</em>, <em>mask_radius=3</em>, <em>masked_value=-10</em>, <em>skip_empty_boxes=True</em>, <em>apply_box_info=True</em>, <em>mask_id=None</em>, <em>exclude_points_outside_density=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Split up the map, creating boxes that time the entire map.</p>
<p>Try to get about target_for_boxes boxes. Do not go over this target</p>
<dl class="docutils">
<dt>If select_final_boxes_based_on_model then make the final boxes just go</dt>
<dd>around the selected parts of the model with cushion defined by
box_cushion and not tile the map.</dd>
<dt>Otherwise select atoms inside the boxes and afterwards expand the boxes</dt>
<dd>with box_cushion</dd>
</dl>
<p>If skip_empty_boxes then skip boxes with no model.</p>
<dl class="docutils">
<dt>Note that this procedure just selects by atom so you can get a single atom</dt>
<dd><p class="first">in a box</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Returns a group_args object containing list of the map_model_manager</dt>
<dd>objects and a list of the selection objects that define which atoms
from the working model are in each object.</dd>
<dt>Normally do work on each map_model_manager to create a new model with</dt>
<dd>the same atoms, then use merge_split_maps_and_models() to replace
coordinates in the original model with those from all the component
models.</dd>
<dt>Optionally carry out the step box_info = get_split_maps_and_models(…)</dt>
<dd>separately with the keyword apply_box_info=False</dd>
<dt>skip_waters and skip_hetero define whether waters and hetero atoms are</dt>
<dd>ignored</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_chain">
<code class="descname">split_up_map_and_model_by_chain</code><span class="sig-paren">(</span><em>skip_waters=False</em>, <em>skip_hetero=False</em>, <em>box_cushion=3</em>, <em>mask_around_unselected_atoms=None</em>, <em>mask_radius=3</em>, <em>masked_value=-10</em>, <em>write_files=False</em>, <em>apply_box_info=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Split up the map, boxing around each chain in the model.</p>
<blockquote>
<div><dl class="docutils">
<dt>Returns a group_args object containing list of the map_model_manager</dt>
<dd>objects and a list of the selection objects that define which atoms
from the working model are in each object.</dd>
<dt>Normally do work on each map_model_manager to create a new model with</dt>
<dd>the same atoms, then use merge_split_maps_and_models() to replace
coordinates in the original model with those from all the component
models.</dd>
<dt>Optionally carry out the step box_info = get_split_maps_and_models(…)</dt>
<dd>separately with the keyword apply_box_info=False</dd>
<dt>skip_waters and skip_hetero define whether waters and hetero atoms are</dt>
<dd>ignored</dd>
</dl>
<p>box_cushion is the padding around the model atoms when creating boxes</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_segment">
<code class="descname">split_up_map_and_model_by_segment</code><span class="sig-paren">(</span><em>skip_waters=False</em>, <em>skip_hetero=False</em>, <em>box_cushion=3</em>, <em>mask_around_unselected_atoms=None</em>, <em>mask_radius=3</em>, <em>masked_value=-10</em>, <em>write_files=False</em>, <em>apply_box_info=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Split up the map, boxing around each segment (each unbroken part of</dt>
<dd><p class="first">each chain) in the model</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Returns a group_args object containing list of the map_model_manager</dt>
<dd>objects and a list of the selection objects that define which atoms
from the working model are in each object.</dd>
<dt>Normally do work on each map_model_manager to create a new model with</dt>
<dd>the same atoms, then use merge_split_maps_and_models() to replace
coordinates in the original model with those from all the component
models.</dd>
<dt>Optionally carry out the step box_info = get_split_maps_and_models(…)</dt>
<dd>separately with the keyword apply_box_info=False</dd>
<dt>skip_waters and skip_hetero define whether waters and hetero atoms are</dt>
<dd>ignored</dd>
</dl>
<p>box_cushion is the padding around the model atoms when creating boxes</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_supplied_selections">
<code class="descname">split_up_map_and_model_by_supplied_selections</code><span class="sig-paren">(</span><em>selection_list</em>, <em>box_cushion=3</em>, <em>mask_around_unselected_atoms=None</em>, <em>mask_radius=3</em>, <em>masked_value=-10</em>, <em>write_files=False</em>, <em>apply_box_info=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.split_up_map_and_model_by_supplied_selections" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Split up the map, boxing around atoms selected with each selection in</dt>
<dd><p class="first">selection_list
Note: a selection can be obtained with:</p>
<blockquote class="last">
<div><blockquote>
<div>self.model().selection(selection_string)</div></blockquote>
<dl class="docutils">
<dt>Returns a group_args object containing list of the map_model_manager</dt>
<dd>objects and a list of the selection objects that define which atoms
from the working model are in each object.</dd>
<dt>Normally do work on each map_model_manager to create a new model with</dt>
<dd>the same atoms, then use merge_split_maps_and_models() to replace
coordinates in the original model with those from all the component
models.</dd>
<dt>Optionally carry out the step box_info = get_split_maps_and_models(…)</dt>
<dd>separately with the keyword apply_box_info=False</dd>
</dl>
<p>box_cushion is the padding around the model atoms when creating boxes</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.superposed_map_manager_from_other">
<code class="descname">superposed_map_manager_from_other</code><span class="sig-paren">(</span><em>other</em>, <em>working_rt_info=None</em>, <em>absolute_rt_info=None</em>, <em>shift_aware_rt_info=None</em>, <em>selection_string=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.superposed_map_manager_from_other" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Identify rotation/translation to map model from other on to model in this</dt>
<dd>object.</dd>
<dt>Optionally apply selection_string to both models before doing the</dt>
<dd>mapping</dd>
</dl>
<p>Then extract map from other to cover map in this object,
Fill in with zero where undefined if wrapping is False.</p>
<dl class="docutils">
<dt>Allow specification of working_rt (applies to working coordinates in</dt>
<dd>other and self), or absolute_rt_info (applies to absolute, original
coordinates)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.tls_from_map">
<code class="descname">tls_from_map</code><span class="sig-paren">(</span><em>map_id_1=None</em>, <em>map_id_2=None</em>, <em>map_id=None</em>, <em>model_id=None</em>, <em>mask_id=None</em>, <em>tls_by_chain=True</em>, <em>apply_tls_to_model=True</em>, <em>iterations=2</em>, <em>skip_waters=True</em>, <em>skip_hetero=True</em>, <em>coordinate_shift_to_apply_before_tlso=None</em>, <em>core_box_size_ratio=None</em>, <em>box_cushion_ratio=None</em>, <em>exclude_points_outside_density=True</em>, <em>d_min=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.tls_from_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.unit_cell_crystal_symmetry">
<code class="descname">unit_cell_crystal_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.unit_cell_crystal_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the unit_cell_crystal_symmetry (full or original symmetry)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.warning_message">
<code class="descname">warning_message</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.warning_message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.write_map">
<code class="descname">write_map</code><span class="sig-paren">(</span><em>file_name</em>, <em>map_id='map_manager'</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.write_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.write_model">
<code class="descname">write_model</code><span class="sig-paren">(</span><em>file_name</em>, <em>model_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.write_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.map_model_manager.xray_structure">
<code class="descname">xray_structure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.map_model_manager.xray_structure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="iotbx.map_model_manager.match_map_model_ncs">
<em class="property">class </em><code class="descclassname">iotbx.map_model_manager.</code><code class="descname">match_map_model_ncs</code><span class="sig-paren">(</span><em>log=None</em>, <em>ignore_symmetry_conflicts=None</em>, <em>absolute_angle_tolerance=0.01</em>, <em>absolute_length_tolerance=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs" title="Permalink to this definition">¶</a></dt>
<dd><p>Use: Container to hold map, model, ncs object and check
consistency and shift origin</p>
<p>Normal usage:</p>
<blockquote>
<div><p>Initialize empty, then read in or add a group of model.manager,
map_manager, and ncs objects</p>
<p>Read in the models, maps, ncs objects</p>
<dl class="docutils">
<dt>Shift origin to (0, 0, 0) and save position of this (0, 0, 0) point in the</dt>
<dd>original coordinate system so that everything can be written out
superimposed on the original locations. This is origin_shift_grid_units
in grid units</dd>
</dl>
<p>NOTE: modifies the model, map_manager, and ncs objects. Call with
deep_copy() of these if originals need to be preserved.</p>
<p>Input models, maps, and ncs_object must all match in crystal_symmetry,
original (unit_cell) crystal_symmetry, and shift_cart for maps)</p>
<p>If map_manager contains an ncs_object and an ncs_object is supplied,
the map_manager receives the supplied ncs_object</p>
<p>absolute_angle_tolerance and absolute_length_tolerance are tolerances
for crystal_symmetry.is_similar_symmetry()</p>
</div></blockquote>
<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.add_map_manager">
<code class="descname">add_map_manager</code><span class="sig-paren">(</span><em>map_manager</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.add_map_manager" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.add_model">
<code class="descname">add_model</code><span class="sig-paren">(</span><em>model</em>, <em>set_model_log_to_null=True</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.add_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.add_ncs_object">
<code class="descname">add_ncs_object</code><span class="sig-paren">(</span><em>ncs_object</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.add_ncs_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.as_map_model_manager">
<code class="descname">as_map_model_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.as_map_model_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Return map_model_manager object with contents of this class
(not a deepcopy)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.check_model_and_set_to_match_map_if_necessary">
<code class="descname">check_model_and_set_to_match_map_if_necessary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.check_model_and_set_to_match_map_if_necessary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.crystal_symmetry">
<code class="descname">crystal_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.crystal_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.deep_copy">
<code class="descname">deep_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.get_coordinate_shift">
<code class="descname">get_coordinate_shift</code><span class="sig-paren">(</span><em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.get_coordinate_shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.map_manager">
<code class="descname">map_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.map_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the map_manager</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.model">
<code class="descname">model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.ncs_object">
<code class="descname">ncs_object</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.ncs_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.read_map">
<code class="descname">read_map</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.read_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.read_model">
<code class="descname">read_model</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.read_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.read_ncs_file">
<code class="descname">read_ncs_file</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.read_ncs_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.set_log">
<code class="descname">set_log</code><span class="sig-paren">(</span><em>log=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.set_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output log file</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.set_original_origin_and_gridding">
<code class="descname">set_original_origin_and_gridding</code><span class="sig-paren">(</span><em>original_origin=None</em>, <em>gridding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.set_original_origin_and_gridding" title="Permalink to this definition">¶</a></dt>
<dd><p>Use map_manager to reset (redefine) the original origin and gridding
of the map.
You can supply just the original origin in grid units, or just the
gridding of the full unit_cell map, or both.</p>
<p>Update shift_cart for model and ncs object if present.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.shift_model_to_match_original_map">
<code class="descname">shift_model_to_match_original_map</code><span class="sig-paren">(</span><em>model=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.shift_model_to_match_original_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.shift_model_to_match_working_map">
<code class="descname">shift_model_to_match_working_map</code><span class="sig-paren">(</span><em>model=None</em>, <em>reverse=False</em>, <em>coordinate_shift=None</em>, <em>new_shift_cart=None</em>, <em>final_crystal_symmetry=None</em>, <em>final_unit_cell_crystal_symmetry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.shift_model_to_match_working_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift a model based on the coordinate shift for the working map.</p>
<dl class="docutils">
<dt>Also match the crystal_symmetry and unit_cell_crystal_symmetry</dt>
<dd>of the model to the map, unless specified as final_crystal_symmetry
and final_unit_cell_crystal_symmetry.</dd>
</dl>
<p>Optionally specify the shift to apply (coordinate shift) and the
new value of the shift recorded in the model (new_shift_cart)</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.shift_ncs_to_match_original_map">
<code class="descname">shift_ncs_to_match_original_map</code><span class="sig-paren">(</span><em>ncs_object=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.shift_ncs_to_match_original_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.shift_ncs_to_match_working_map">
<code class="descname">shift_ncs_to_match_working_map</code><span class="sig-paren">(</span><em>ncs_object=None</em>, <em>reverse=False</em>, <em>coordinate_shift=None</em>, <em>new_shift_cart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.shift_ncs_to_match_working_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift an ncs object to match the working map (based
on self._map_manager.origin_shift_grid_units)</p>
<p>The working map is the current map in its current location. Typically
origin is at (0,0,0).</p>
<p>This shifts an ncs object (typically is in its original location) to
match this working map.</p>
<p>If the ncs object was already shifted (as reflected in its shift_cart())
it will receive the appropriate additional shift to match current map.</p>
<p>If coordinate_shift is specified, it is the target final coordinate shift
instead of the shift_cart() for the working map.</p>
</dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.shift_origin">
<code class="descname">shift_origin</code><span class="sig-paren">(</span><em>desired_origin=(0</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.shift_origin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.show_summary">
<code class="descname">show_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.show_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.unit_cell_crystal_symmetry">
<code class="descname">unit_cell_crystal_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.unit_cell_crystal_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.write_map">
<code class="descname">write_map</code><span class="sig-paren">(</span><em>file_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.write_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="iotbx.map_model_manager.match_map_model_ncs.write_model">
<code class="descname">write_model</code><span class="sig-paren">(</span><em>file_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.match_map_model_ncs.write_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.residue_group_is_linked_to_previous">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">residue_group_is_linked_to_previous</code><span class="sig-paren">(</span><em>rg</em>, <em>previous_rg</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.residue_group_is_linked_to_previous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="iotbx.map_model_manager.run_anisotropic_scaling_as_class">
<em class="property">class </em><code class="descclassname">iotbx.map_model_manager.</code><code class="descname">run_anisotropic_scaling_as_class</code><span class="sig-paren">(</span><em>map_model_manager=None</em>, <em>direction_vectors=None</em>, <em>scale_factor_info=None</em>, <em>setup_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.run_anisotropic_scaling_as_class" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="iotbx.map_model_manager.run_fsc_as_class">
<em class="property">class </em><code class="descclassname">iotbx.map_model_manager.</code><code class="descname">run_fsc_as_class</code><span class="sig-paren">(</span><em>map_model_manager=None</em>, <em>run_list=None</em>, <em>box_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.run_fsc_as_class" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="iotbx.map_model_manager.set_nearby_empty_values">
<code class="descclassname">iotbx.map_model_manager.</code><code class="descname">set_nearby_empty_values</code><span class="sig-paren">(</span><em>map_manager</em>, <em>set_values_map_manager</em>, <em>xyz_list</em>, <em>radius</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#iotbx.map_model_manager.set_nearby_empty_values" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Set values within radii of xyz_list points to value if not already</dt>
<dd>set</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">iotbx.managers</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#module-iotbx.map_manager">API documentation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">iotbx - file readers and writers</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="iotbx.file_reader.html"
                        title="next chapter">iotbx.file_reader - generic file input</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/iotbx/iotbx.managers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="iotbx.file_reader.html" title="iotbx.file_reader - generic file input"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="iotbx - file readers and writers"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CCTBX Developer documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >iotbx - file readers and writers</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, University of California.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>